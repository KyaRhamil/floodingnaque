# Floodingnaque Frontend Development Guide

> Complete guide for building the Floodingnaque flood prediction frontend application.
> Last Updated: January 2026

---

## Table of Contents

1. [Overview](#1-overview)
2. [Tech Stack](#2-tech-stack)
3. [Project Structure](#3-project-structure)
4. [Getting Started](#4-getting-started)
5. [Configuration Files](#5-configuration-files)
6. [Core Infrastructure](#6-core-infrastructure)
7. [Type Definitions](#7-type-definitions)
8. [State Management](#8-state-management)
9. [API Integration](#9-api-integration)
10. [Authentication](#10-authentication)
11. [Real-time Features](#11-real-time-features)
12. [UI Components](#12-ui-components)
13. [Feature Modules](#13-feature-modules)
14. [Testing Strategy](#14-testing-strategy)
15. [Development Workflow](#15-development-workflow)
16. [Deployment](#16-deployment)
17. [MVP Roadmap](#17-mvp-roadmap)

---

## 1. Overview

### Project Purpose
Floodingnaque is a flood prediction system for Parañaque City, Philippines. The frontend provides:
- Real-time flood risk predictions
- Interactive map visualization
- Historical weather data analysis
- Alert management and notifications
- Report generation

### Architecture
┌─────────────────────────────────────────────────────────────────┐
│ FRONTEND │
│ https://floodingnaque.vercel.app │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │ React + TypeScript + Vite + Tailwind + Zustand │ │
│ └─────────────────────────────────────────────────────────┘ │
└─────────────────────────┬───────────────────────────────────────┘
│ HTTPS
▼
┌─────────────────────────────────────────────────────────────────┐
│ BACKEND API │
│ https://your-backend.railway.app │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │ Flask + SQLAlchemy + Celery + Redis │ │
│ └─────────────────────────────────────────────────────────┘ │
└─────────────────────────┬───────────────────────────────────────┘
│
┌───────────────┼───────────────┐
▼ ▼ ▼
┌──────────┐ ┌──────────┐ ┌──────────┐
│ Supabase │ │ Redis │ │ External │
│ Postgres │ │ Cloud │ │ APIs │
└──────────┘ └──────────┘ └──────────┘


### Backend Status
✅ **Complete and Ready** — All APIs documented and tested.

| Feature | Endpoint | Status |
|---------|----------|--------|
| Predictions | `POST /predict` | ✅ Ready |
| Weather Data | `GET /data` | ✅ Ready |
| Alerts | `GET /api/alerts` | ✅ Ready |
| Real-time SSE | `GET /sse/alerts` | ✅ Ready |
| Authentication | `/api/users/*` | ✅ Ready |
| Webhooks | `/api/webhooks/*` | ✅ Ready |
| Export | `/api/export/*` | ✅ Ready |

### API Base URLs
Development: http://localhost:5000
Production: https://your-backend.railway.app # Update when deployed

> **Note**: Frontend is hosted on Vercel (`https://floodingnaque.vercel.app`).
> Backend requires separate hosting (Railway, Render, Heroku, etc.) since Flask cannot run on Vercel.

---

## 2. Tech Stack

### Core Framework
| Technology | Version | Purpose |
|------------|---------|---------|
| React | 18.x | UI framework |
| TypeScript | 5.x | Type safety |
| Vite | 5.x | Build tool & dev server |

### Styling
| Technology | Purpose |
|------------|---------|
| Tailwind CSS | Utility-first styling |
| shadcn/ui | Pre-built accessible components |
| Lucide React | Icon library |
| tailwindcss-animate | Animation utilities |

### State & Data
| Technology | Purpose |
|------------|---------|
| TanStack Query v5 | Server state management |
| Zustand | Client state management |
| Axios | HTTP client |

### Forms & Validation
| Technology | Purpose |
|------------|---------|
| React Hook Form | Form state management |
| Zod | Schema validation |
| @hookform/resolvers | RHF + Zod integration |

### Visualization
| Technology | Purpose |
|------------|---------|
| Leaflet + React Leaflet | Map visualization |
| Recharts | Charts and graphs |

### Testing
| Technology | Purpose |
|------------|---------|
| Vitest | Unit testing |
| React Testing Library | Component testing |
| MSW v2 | API mocking |
| Playwright | E2E testing |

### Build & Tooling
| Technology | Purpose |
|------------|---------|
| ESLint | Code linting |
| Prettier | Code formatting |
| TypeScript ESLint | TS-specific linting |

---

## 3. Project Structure
frontend/
├── .env.development # Dev environment variables
├── .env.production # Prod environment variables
├── .env.example # Template for environment vars
├── .eslintrc.cjs # ESLint configuration
├── .prettierrc # Prettier configuration
├── .gitignore # Git ignore rules
├── index.html # HTML entry point
├── package.json # Dependencies & scripts
├── tsconfig.json # TypeScript configuration
├── tsconfig.node.json # TypeScript config for Vite
├── vite.config.ts # Vite configuration
├── tailwind.config.js # Tailwind configuration
├── postcss.config.js # PostCSS configuration
├── components.json # shadcn/ui configuration
├── playwright.config.ts # Playwright E2E config
│
├── public/
│ ├── favicon.ico
│ ├── manifest.json
│ ├── robots.txt
│ └── icons/ # PWA icons
│
└── src/
├── main.tsx # Application entry point
├── App.tsx # Root component with routing
├── vite-env.d.ts # Vite type definitions
│
├── app/ # Route pages
│ ├── layout.tsx # Root layout wrapper
│ ├── page.tsx # Home/Dashboard page
│ ├── login/
│ │ └── page.tsx
│ ├── predict/
│ │ └── page.tsx
│ ├── history/
│ │ └── page.tsx
│ ├── alerts/
│ │ └── page.tsx
│ ├── reports/
│ │ └── page.tsx
│ ├── settings/
│ │ └── page.tsx
│ └── admin/
│ └── page.tsx
│
├── assets/
│ ├── fonts/
│ ├── icons/
│ └── images/
│ └── logo.svg
│
├── components/
│ ├── ui/ # shadcn/ui base components
│ │ ├── button.tsx
│ │ ├── card.tsx
│ │ ├── input.tsx
│ │ ├── label.tsx
│ │ ├── select.tsx
│ │ ├── dialog.tsx
│ │ ├── toast.tsx
│ │ ├── skeleton.tsx
│ │ ├── table.tsx
│ │ ├── badge.tsx
│ │ └── ...
│ ├── charts/
│ │ ├── RiskGauge.tsx
│ │ ├── PredictionChart.tsx
│ │ ├── WeatherChart.tsx
│ │ └── AlertTrend.tsx
│ ├── map/
│ │ ├── FloodMap.tsx
│ │ ├── LocationPicker.tsx
│ │ ├── RiskOverlay.tsx
│ │ └── MapControls.tsx
│ ├── tables/
│ │ ├── DataTable.tsx
│ │ ├── columns.tsx
│ │ ├── PredictionHistory.tsx
│ │ └── AlertsTable.tsx
│ ├── feedback/
│ │ ├── Loader.tsx
│ │ ├── ErrorBoundary.tsx
│ │ ├── EmptyState.tsx
│ │ └── ConnectionStatus.tsx
│ └── layout/
│ ├── Header.tsx
│ ├── Sidebar.tsx
│ ├── Footer.tsx
│ ├── MobileNav.tsx
│ └── PageContainer.tsx
│
├── config/
│ ├── api.config.ts # API URLs & settings
│ ├── app.config.ts # App-wide constants
│ ├── map.config.ts # Map defaults (Parañaque)
│ └── navigation.config.ts # Nav menu items
│
├── features/
│ ├── auth/
│ │ ├── components/
│ │ │ ├── LoginForm.tsx
│ │ │ ├── RegisterForm.tsx
│ │ │ ├── ProtectedRoute.tsx
│ │ │ └── UserMenu.tsx
│ │ ├── hooks/
│ │ │ ├── useAuth.ts
│ │ │ └── useTokenRefresh.ts
│ │ └── services/
│ │ └── authApi.ts
│ ├── flooding/
│ │ ├── components/
│ │ │ ├── PredictionForm.tsx
│ │ │ ├── RiskDisplay.tsx
│ │ │ ├── RiskCard.tsx
│ │ │ ├── WeatherInputs.tsx
│ │ │ └── QuickPredict.tsx
│ │ ├── hooks/
│ │ │ ├── usePrediction.ts
│ │ │ └── useWeatherData.ts
│ │ ├── services/
│ │ │ └── predictionApi.ts
│ │ └── utils/
│ │ ├── temperature.ts
│ │ └── riskCalculations.ts
│ ├── alerts/
│ │ ├── components/
│ │ │ ├── AlertList.tsx
│ │ │ ├── AlertCard.tsx
│ │ │ ├── AlertBanner.tsx
│ │ │ └── AlertFilters.tsx
│ │ ├── hooks/
│ │ │ ├── useAlerts.ts
│ │ │ └── useAlertStream.ts
│ │ └── services/
│ │ └── alertsApi.ts
│ ├── weather/
│ │ ├── components/
│ │ │ ├── WeatherCard.tsx
│ │ │ ├── WeatherHistory.tsx
│ │ │ └── WeatherStats.tsx
│ │ ├── hooks/
│ │ │ └── useWeather.ts
│ │ └── services/
│ │ └── weatherApi.ts
│ ├── reports/
│ │ ├── components/
│ │ │ ├── ReportGenerator.tsx
│ │ │ ├── ExportButton.tsx
│ │ │ └── ReportPreview.tsx
│ │ ├── hooks/
│ │ │ └── useExport.ts
│ │ └── services/
│ │ └── exportApi.ts
│ └── settings/
│ ├── components/
│ │ ├── ProfileForm.tsx
│ │ ├── WebhookManager.tsx
│ │ ├── NotificationSettings.tsx
│ │ └── ApiKeyManager.tsx
│ ├── hooks/
│ │ └── useSettings.ts
│ └── services/
│ └── settingsApi.ts
│
├── hooks/ # Shared hooks
│ ├── useApi.ts
│ ├── useDebounce.ts
│ ├── useLocalStorage.ts
│ ├── useMediaQuery.ts
│ ├── useOnlineStatus.ts
│ └── useToast.ts
│
├── lib/
│ ├── api-client.ts # Axios instance with interceptors
│ ├── query-client.ts # React Query configuration
│ ├── cn.ts # Tailwind class utility
│ ├── utils.ts # General helper functions
│ ├── date.ts # Date formatting utilities
│ └── validators.ts # Zod schemas
│
├── providers/
│ ├── index.tsx # Combined providers wrapper
│ ├── QueryProvider.tsx # React Query provider
│ ├── AuthProvider.tsx # Authentication context
│ ├── ThemeProvider.tsx # Theme context
│ └── ToastProvider.tsx # Toast notifications
│
├── state/
│ └── stores/
│ ├── authStore.ts # Auth state (Zustand)
│ ├── alertStore.ts # Real-time alerts state
│ └── uiStore.ts # UI state (theme, sidebar)
│
├── styles/
│ ├── globals.css # Tailwind imports & base styles
│ └── leaflet.css # Leaflet map overrides
│
├── tests/
│ ├── setup.ts # Test setup file
│ ├── test-utils.tsx # Custom render utilities
│ ├── mocks/
│ │ ├── handlers.ts # MSW request handlers
│ │ ├── server.ts # MSW server setup
│ │ └── data.ts # Mock data fixtures
│ ├── e2e/
│ │ ├── auth.spec.ts
│ │ ├── prediction.spec.ts
│ │ └── dashboard.spec.ts
│ ├── integration/
│ │ └── api.test.ts
│ └── unit/
│ ├── components/
│ │ └── RiskDisplay.test.tsx
│ ├── hooks/
│ │ └── usePrediction.test.ts
│ └── utils/
│ └── temperature.test.ts
│
└── types/
├── api/
│ ├── index.ts # Re-exports
│ ├── common.ts # ApiResponse, ApiError, Pagination
│ ├── prediction.ts # Prediction types
│ ├── weather.ts # Weather data types
│ ├── alert.ts # Alert types
│ └── auth.ts # Auth types
├── domain/
│ ├── user.ts # User model
│ └── risk.ts # Risk level types
└── global.d.ts # Global type augmentations

---

## 4. Getting Started

### Prerequisites
- Node.js 18+ (LTS recommended)
- npm 9+ or pnpm 8+
- Backend running on `http://localhost:5000`

### Quick Start

```powershell
# Navigate to frontend directory
cd d:\floodingnaque\frontend

# Create Vite project
npm create vite@latest . -- --template react-ts

# Install dependencies
npm install

# Install core packages
npm install axios @tanstack/react-query @tanstack/react-query-devtools zustand
npm install react-router-dom
npm install react-hook-form @hookform/resolvers zod
npm install leaflet react-leaflet
npm install recharts
npm install lucide-react
npm install date-fns
npm install clsx tailwind-merge class-variance-authority
npm install @radix-ui/react-dialog @radix-ui/react-dropdown-menu
npm install @radix-ui/react-label @radix-ui/react-select
npm install @radix-ui/react-slot @radix-ui/react-toast
npm install @radix-ui/react-tabs @radix-ui/react-avatar

# Install dev dependencies
npm install -D tailwindcss postcss autoprefixer
npm install -D @types/leaflet
npm install -D vitest @vitest/ui @testing-library/react @testing-library/jest-dom jsdom
npm install -D msw
npm install -D @playwright/test
npm install -D eslint @typescript-eslint/eslint-plugin @typescript-eslint/parser
npm install -D eslint-plugin-react-hooks eslint-plugin-react-refresh
npm install -D prettier eslint-config-prettier
npm install -D tailwindcss-animate

# Initialize Tailwind
npx tailwindcss init -p

# Initialize shadcn/ui
npx shadcn-ui@latest init

# Start development server
npm run dev

Package.json Scripts
{
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "lint:fix": "eslint . --ext ts,tsx --fix",
    "format": "prettier --write \"src/**/*.{ts,tsx,css,json}\"",
    "typecheck": "tsc --noEmit",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage",
    "test:e2e": "playwright test",
    "test:e2e:ui": "playwright test --ui"
  }
}

5. Configuration Files

### 5.1 Monorepo Structure with pnpm Workspaces

To improve project organization and share types between frontend and backend, we'll set up a monorepo structure:

```yaml
# pnpm-workspace.yaml
packages:
  - 'packages/*'
  - 'frontend'
  - 'shared-types'
```

```json
// package.json (root)
{
  "name": "floodingnaque-monorepo",
  "private": true,
  "workspaces": [
    "frontend",
    "shared-types"
  ],
  "scripts": {
    "dev": "pnpm --parallel --filter \"./packages/*\" dev",
    "build": "pnpm --filter \"./packages/*\" build",
    "test": "pnpm --recursive test",
    "clean": "rm -rf node_modules && rm -rf */node_modules",
    "install-all": "pnpm install && cd frontend && pnpm install && cd ../shared-types && pnpm install"
  },
  "devDependencies": {
    "typescript": "^5.0.0"
  }
}
```

### 5.2 Shared Types Package

Create a shared types package to maintain API contract consistency:

```json
// packages/shared-types/package.json
{
  "name": "@floodingnaque/shared-types",
  "version": "1.0.0",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "files": [
    "dist"
  ],
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch",
    "clean": "rm -rf dist"
  },
  "devDependencies": {
    "typescript": "^5.0.0"
  }
}
```

```json
// packages/shared-types/tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "node",
    "declaration": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "node_modules",
    "dist"
  ]
}
```

```typescript
// packages/shared-types/src/api/index.ts
export * from './common';
export * from './prediction';
export * from './weather';
export * from './alert';
export * from './auth';
```

```typescript
// packages/shared-types/src/api/common.ts
export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: ApiError;
  request_id: string;
}

export interface ApiError {
  code: string;
  title: string;
  status: number;
  detail: string;
  errors?: FieldError[];
  retry_after?: number;
}

export interface FieldError {
  field: string;
  message: string;
}

export interface PaginatedResponse<T> {
  success: boolean;
  data: T[];
  total: number;
  limit: number;
  offset: number;
  count: number;
  request_id: string;
}

export interface PaginationParams {
  limit?: number;
  offset?: number;
  sort_by?: string;
  order?: 'asc' | 'desc';
}

export interface DateRangeParams {
  start_date?: string;
  end_date?: string;
}
```

Then update the frontend package.json to reference shared types:

```json
// frontend/package.json
{
  "name": "floodingnaque-frontend",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "lint:fix": "eslint . --ext ts,tsx --fix",
    "format": "prettier --write \"src/**/*.{ts,tsx,css,json}\"",
    "typecheck": "tsc --noEmit",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage",
    "test:e2e": "playwright test",
    "test:e2e:ui": "playwright test --ui"
  },
  "dependencies": {
    "@floodingnaque/shared-types": "workspace:*",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.21.0",
    "@tanstack/react-query": "^5.17.0",
    "@tanstack/react-query-devtools": "^5.17.0",
    "zustand": "^4.4.7",
    "axios": "^1.6.5",
    "react-hook-form": "^7.49.2",
    "@hookform/resolvers": "^3.3.3",
    "zod": "^3.22.4",
    "leaflet": "^1.9.4",
    "react-leaflet": "^4.2.1",
    "recharts": "^2.10.3",
    "lucide-react": "^0.303.0",
    "date-fns": "^3.2.0",
    "clsx": "^2.1.0",
    "tailwind-merge": "^2.2.0",
    "class-variance-authority": "^0.7.0",
    "@radix-ui/react-dialog": "^1.0.5",
    "@radix-ui/react-dropdown-menu": "^2.0.6",
    "@radix-ui/react-label": "^2.0.2",
    "@radix-ui/react-select": "^2.0.0",
    "@radix-ui/react-slot": "^1.0.2",
    "@radix-ui/react-toast": "^1.1.5",
    "@radix-ui/react-tabs": "^1.0.4",
    "@radix-ui/react-avatar": "^1.0.4",
    "@radix-ui/react-separator": "^1.0.3"
  },
  "devDependencies": {
    "@types/react": "^18.2.47",
    "@types/react-dom": "^18.2.18",
    "@types/leaflet": "^1.9.8",
    "@typescript-eslint/eslint-plugin": "^6.18.0",
    "@typescript-eslint/parser": "^6.18.0",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.16",
    "eslint": "^8.56.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.5",
    "postcss": "^8.4.33",
    "prettier": "^3.2.0",
    "tailwindcss": "^3.4.1",
    "tailwindcss-animate": "^1.0.7",
    "typescript": "^5.3.3",
    "vite": "^5.0.11",
    "vitest": "^1.2.0",
    "@vitest/ui": "^1.2.0",
    "@testing-library/react": "^14.1.2",
    "@testing-library/jest-dom": "^6.2.0",
    "jsdom": "^23.2.0",
    "msw": "^2.0.12",
    "@playwright/test": "^1.41.0"
  }
}
```
package.json
{
  "name": "floodingnaque-frontend",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "lint:fix": "eslint . --ext ts,tsx --fix",
    "format": "prettier --write \"src/**/*.{ts,tsx,css,json}\"",
    "typecheck": "tsc --noEmit",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage",
    "test:e2e": "playwright test",
    "test:e2e:ui": "playwright test --ui"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.21.0",
    "@tanstack/react-query": "^5.17.0",
    "@tanstack/react-query-devtools": "^5.17.0",
    "zustand": "^4.4.7",
    "axios": "^1.6.5",
    "react-hook-form": "^7.49.2",
    "@hookform/resolvers": "^3.3.3",
    "zod": "^3.22.4",
    "leaflet": "^1.9.4",
    "react-leaflet": "^4.2.1",
    "recharts": "^2.10.3",
    "lucide-react": "^0.303.0",
    "date-fns": "^3.2.0",
    "clsx": "^2.1.0",
    "tailwind-merge": "^2.2.0",
    "class-variance-authority": "^0.7.0",
    "@radix-ui/react-dialog": "^1.0.5",
    "@radix-ui/react-dropdown-menu": "^2.0.6",
    "@radix-ui/react-label": "^2.0.2",
    "@radix-ui/react-select": "^2.0.0",
    "@radix-ui/react-slot": "^1.0.2",
    "@radix-ui/react-toast": "^1.1.5",
    "@radix-ui/react-tabs": "^1.0.4",
    "@radix-ui/react-avatar": "^1.0.4",
    "@radix-ui/react-separator": "^1.0.3"
  },
  "devDependencies": {
    "@types/react": "^18.2.47",
    "@types/react-dom": "^18.2.18",
    "@types/leaflet": "^1.9.8",
    "@typescript-eslint/eslint-plugin": "^6.18.0",
    "@typescript-eslint/parser": "^6.18.0",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.16",
    "eslint": "^8.56.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.5",
    "postcss": "^8.4.33",
    "prettier": "^3.2.0",
    "tailwindcss": "^3.4.1",
    "tailwindcss-animate": "^1.0.7",
    "typescript": "^5.3.3",
    "vite": "^5.0.11",
    "vitest": "^1.2.0",
    "@vitest/ui": "^1.2.0",
    "@testing-library/react": "^14.1.2",
    "@testing-library/jest-dom": "^6.2.0",
    "jsdom": "^23.2.0",
    "msw": "^2.0.12",
    "@playwright/test": "^1.41.0"
  }
}
vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:5000',
        changeOrigin: true,
      },
      '/predict': {
        target: 'http://localhost:5000',
        changeOrigin: true,
      },
      '/data': {
        target: 'http://localhost:5000',
        changeOrigin: true,
      },
      '/ingest': {
        target: 'http://localhost:5000',
        changeOrigin: true,
      },
      '/sse': {
        target: 'http://localhost:5000',
        changeOrigin: true,
      },
      '/health': {
        target: 'http://localhost:5000',
        changeOrigin: true,
      },
      '/status': {
        target: 'http://localhost:5000',
        changeOrigin: true,
      },
    },
  },
  build: {
    outDir: 'dist',
    sourcemap: true,
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom', 'react-router-dom'],
          query: ['@tanstack/react-query'],
          charts: ['recharts'],
          map: ['leaflet', 'react-leaflet'],
        },
      },
    },
  },
});
tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
tsconfig.node.json
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true,
    "strict": true
  },
  "include": ["vite.config.ts", "playwright.config.ts"]
}
tailwind.config.js
/** @type {import('tailwindcss').Config} */
export default {
  darkMode: ['class'],
  content: [
    './index.html',
    './src/**/*.{js,ts,jsx,tsx}',
  ],
  theme: {
    container: {
      center: true,
      padding: '2rem',
      screens: {
        '2xl': '1400px',
      },
    },
    extend: {
      colors: {
        border: 'hsl(var(--border))',
        input: 'hsl(var(--input))',
        ring: 'hsl(var(--ring))',
        background: 'hsl(var(--background))',
        foreground: 'hsl(var(--foreground))',
        primary: {
          DEFAULT: 'hsl(var(--primary))',
          foreground: 'hsl(var(--primary-foreground))',
        },
        secondary: {
          DEFAULT: 'hsl(var(--secondary))',
          foreground: 'hsl(var(--secondary-foreground))',
        },
        destructive: {
          DEFAULT: 'hsl(var(--destructive))',
          foreground: 'hsl(var(--destructive-foreground))',
        },
        muted: {
          DEFAULT: 'hsl(var(--muted))',
          foreground: 'hsl(var(--muted-foreground))',
        },
        accent: {
          DEFAULT: 'hsl(var(--accent))',
          foreground: 'hsl(var(--accent-foreground))',
        },
        popover: {
          DEFAULT: 'hsl(var(--popover))',
          foreground: 'hsl(var(--popover-foreground))',
        },
        card: {
          DEFAULT: 'hsl(var(--card))',
          foreground: 'hsl(var(--card-foreground))',
        },
        // Risk level colors
        risk: {
          safe: '#4caf50',
          alert: '#ff9800',
          critical: '#d32f2f',
        },
      },
      borderRadius: {
        lg: 'var(--radius)',
        md: 'calc(var(--radius) - 2px)',
        sm: 'calc(var(--radius) - 4px)',
      },
      fontFamily: {
        sans: ['Inter', 'system-ui', 'sans-serif'],
      },
      keyframes: {
        'accordion-down': {
          from: { height: '0' },
          to: { height: 'var(--radix-accordion-content-height)' },
        },
        'accordion-up': {
          from: { height: 'var(--radix-accordion-content-height)' },
          to: { height: '0' },
        },
        'pulse-risk': {
          '0%, 100%': { opacity: '1' },
          '50%': { opacity: '0.5' },
        },
      },
      animation: {
        'accordion-down': 'accordion-down 0.2s ease-out',
        'accordion-up': 'accordion-up 0.2s ease-out',
        'pulse-risk': 'pulse-risk 2s ease-in-out infinite',
      },
    },
  },
  plugins: [require('tailwindcss-animate')],
};
.eslintrc.cjs
module.exports = {
  root: true,
  env: { browser: true, es2020: true },
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:react-hooks/recommended',
    'prettier',
  ],
  ignorePatterns: ['dist', '.eslintrc.cjs'],
  parser: '@typescript-eslint/parser',
  plugins: ['react-refresh'],
  rules: {
    'react-refresh/only-export-components': [
      'warn',
      { allowConstantExport: true },
    ],
    '@typescript-eslint/no-unused-vars': ['error', { argsIgnorePattern: '^_' }],
    '@typescript-eslint/no-explicit-any': 'warn',
  },
};
.prettierrc
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 2,
  "useTabs": false
}

Environment Files

.env.example

# API Configuration
VITE_API_BASE_URL=http://localhost:5000
VITE_SSE_URL=http://localhost:5000/api/v1/sse

# App Configuration
VITE_APP_NAME=Floodingnaque
VITE_APP_VERSION=1.0.0

# Map Configuration (Parañaque City, Philippines)
VITE_MAP_DEFAULT_LAT=14.4793
VITE_MAP_DEFAULT_LNG=121.0198
VITE_MAP_DEFAULT_ZOOM=13

# Feature Flags
VITE_ENABLE_SSE=true
VITE_ENABLE_MOCK_API=false

# Sentry (Optional)
VITE_SENTRY_DSN=

.env.development

VITE_API_BASE_URL=http://localhost:5000
VITE_SSE_URL=http://localhost:5000/api/v1/sse
VITE_APP_NAME=Floodingnaque (Dev)
VITE_APP_VERSION=1.0.0-dev
VITE_MAP_DEFAULT_LAT=14.4793
VITE_MAP_DEFAULT_LNG=121.0198
VITE_MAP_DEFAULT_ZOOM=13
VITE_ENABLE_SSE=true
VITE_ENABLE_MOCK_API=false

.env.production

# UPDATE THIS when backend is deployed
VITE_API_BASE_URL=https://your-backend.railway.app
VITE_SSE_URL=https://your-backend.railway.app/api/v1/sse
VITE_APP_NAME=Floodingnaque
VITE_APP_VERSION=1.0.0
VITE_MAP_DEFAULT_LAT=14.4793
VITE_MAP_DEFAULT_LNG=121.0198
VITE_MAP_DEFAULT_ZOOM=13
VITE_ENABLE_SSE=true
VITE_ENABLE_MOCK_API=false
VITE_SENTRY_DSN=https://your-sentry-dsn

components.json (shadcn/ui)

{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.js",
    "css": "src/styles/globals.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/cn"
  }
}

6. Core Infrastructure

src/main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import App from './App';
import { Providers } from './providers';
import './styles/globals.css';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <BrowserRouter>
      <Providers>
        <App />
      </Providers>
    </BrowserRouter>
  </React.StrictMode>
);

src/App.tsx
import { Routes, Route, Navigate } from 'react-router-dom';
import { useAuthStore } from '@/state/stores/authStore';
import { ProtectedRoute } from '@/features/auth/components/ProtectedRoute';
import Layout from '@/app/layout';
import { Toaster } from '@/components/ui/toaster';

// Pages
import LoginPage from '@/app/login/page';
import DashboardPage from '@/app/page';
import PredictPage from '@/app/predict/page';
import HistoryPage from '@/app/history/page';
import AlertsPage from '@/app/alerts/page';
import ReportsPage from '@/app/reports/page';
import SettingsPage from '@/app/settings/page';
import AdminPage from '@/app/admin/page';

export default function App() {
  const isAuthenticated = useAuthStore((state) => state.isAuthenticated);

  return (
    <>
      <Routes>
        {/* Public routes */}
        <Route
          path="/login"
          element={isAuthenticated ? <Navigate to="/" replace /> : <LoginPage />}
        />

        {/* Protected routes */}
        <Route element={<ProtectedRoute />}>
          <Route element={<Layout />}>
            <Route path="/" element={<DashboardPage />} />
            <Route path="/predict" element={<PredictPage />} />
            <Route path="/history" element={<HistoryPage />} />
            <Route path="/alerts" element={<AlertsPage />} />
            <Route path="/reports" element={<ReportsPage />} />
            <Route path="/settings" element={<SettingsPage />} />
            <Route path="/admin" element={<AdminPage />} />
          </Route>
        </Route>

        {/* Fallback */}
        <Route path="*" element={<Navigate to="/" replace />} />
      </Routes>
      <Toaster />
    </>
  );
}
src/providers/index.tsx
import { ReactNode } from 'react';
import { QueryProvider } from './QueryProvider';
import { ThemeProvider } from './ThemeProvider';

interface ProvidersProps {
  children: ReactNode;
}

export function Providers({ children }: ProvidersProps) {
  return (
    <QueryProvider>
      <ThemeProvider defaultTheme="light" storageKey="floodingnaque-theme">
        {children}
      </ThemeProvider>
    </QueryProvider>
  );
}
src/providers/QueryProvider.tsx
import { ReactNode, useState } from 'react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';

interface QueryProviderProps {
  children: ReactNode;
}

export function QueryProvider({ children }: QueryProviderProps) {
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: 60 * 1000,
            gcTime: 5 * 60 * 1000,
            retry: 3,
            retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
            refetchOnWindowFocus: false,
          },
          mutations: {
            retry: 1,
          },
        },
      })
  );

  return (
    <QueryClientProvider client={queryClient}>
      {children}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}
src/providers/ThemeProvider.tsx
import { createContext, useContext, useEffect, useState, ReactNode } from 'react';

type Theme = 'dark' | 'light';

interface ThemeProviderState {
  theme: Theme;
  setTheme: (theme: Theme) => void;
}

const ThemeProviderContext = createContext<ThemeProviderState | undefined>(undefined);

interface ThemeProviderProps {
  children: ReactNode;
  defaultTheme?: Theme;
  storageKey?: string;
}

export function ThemeProvider({
  children,
  defaultTheme = 'light',
  storageKey = 'ui-theme',
}: ThemeProviderProps) {
  const [theme, setTheme] = useState<Theme>(
    () => (localStorage.getItem(storageKey) as Theme) || defaultTheme
  );

  useEffect(() => {
    const root = window.document.documentElement;
    root.classList.remove('light', 'dark');

    root.classList.add(theme);
  }, [theme]);

  const value = {
    theme,
    setTheme: (theme: Theme) => {
      localStorage.setItem(storageKey, theme);
      setTheme(theme);
    },
  };

  return <ThemeProviderContext.Provider value={value}>{children}</ThemeProviderContext.Provider>;
}

export const useTheme = () => {
  const context = useContext(ThemeProviderContext);
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
};
src/styles/globals.css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 221.2 83.2% 53.3%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 221.2 83.2% 53.3%;
    --radius: 0.5rem;
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
    --primary: 217.2 91.2% 59.8%;
    --primary-foreground: 222.2 47.4% 11.2%;
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 224.3 76.3% 48%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
    font-feature-settings: "rlig" 1, "calt" 1;
  }
}

/* Scrollbar styling */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  @apply bg-muted;
}

::-webkit-scrollbar-thumb {
  @apply bg-muted-foreground/30 rounded-full;
}

::-webkit-scrollbar-thumb:hover {
  @apply bg-muted-foreground/50;
}

/* Leaflet map fixes */
.leaflet-container {
  @apply h-full w-full z-0 rounded-lg;
}

.leaflet-control-zoom {
  @apply border-none shadow-lg;
}

.leaflet-control-zoom a {
  @apply bg-background text-foreground border-border;
}

7. Type Definitions

src/types/api/common.ts
export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: ApiError;
  request_id: string;
}

export interface ApiError {
  code: string;
  title: string;
  status: number;
  detail: string;
  errors?: FieldError[];
  retry_after?: number;
}

export interface FieldError {
  field: string;
  message: string;
}

export interface PaginatedResponse<T> {
  success: boolean;
  data: T[];
  total: number;
  limit: number;
  offset: number;
  count: number;
  request_id: string;
}

export interface PaginationParams {
  limit?: number;
  offset?: number;
  sort_by?: string;
  order?: 'asc' | 'desc';
}

export interface DateRangeParams {
  start_date?: string;
  end_date?: string;
}

src/types/api/prediction.ts
export interface PredictionRequest {
  temperature: number;
  humidity: number;
  precipitation: number;
  wind_speed?: number;
  pressure?: number;
}

export interface PredictionResponse {
  prediction: 0 | 1;
  flood_risk: 'high' | 'low';
  risk_level: RiskLevel;
  risk_label: RiskLabel;
  risk_color: string;
  risk_description: string;
  probability: number;
  confidence: number;
  model_version: string;
  cache_hit: boolean;
  request_id: string;
}

export type RiskLevel = 0 | 1 | 2;
export type RiskLabel = 'Safe' | 'Alert' | 'Critical';

export interface RiskConfig {
  level: RiskLevel;
  label: RiskLabel;
  color: string;
  bgColor: string;
  description: string;
  icon: string;
}

export const RISK_CONFIGS: Record<RiskLevel, RiskConfig> = {
  0: {
    level: 0,
    label: 'Safe',
    color: '#4caf50',
    bgColor: 'bg-green-500',
    description: 'No significant flood risk. Normal conditions.',
    icon: 'CheckCircle',
  },
  1: {
    level: 1,
    label: 'Alert',
    color: '#ff9800',
    bgColor: 'bg-orange-500',
    description: 'Moderate flood risk. Stay informed and prepared.',
    icon: 'AlertTriangle',
  },
  2: {
    level: 2,
    label: 'Critical',
    color: '#d32f2f',
    bgColor: 'bg-red-600',
    description: 'Severe flood risk. Take immediate precautions.',
    icon: 'XCircle',
  },
};

src/types/api/weather.ts
export interface WeatherData {
  id: number;
  temperature: number;
  humidity: number;
  precipitation: number;
  wind_speed?: number;
  pressure?: number;
  source: WeatherSource;
  timestamp: string;
  created_at: string;
}

export type WeatherSource = 'OWM' | 'Manual' | 'Meteostat' | 'Google';

export interface WeatherDataParams {
  limit?: number;
  offset?: number;
  start_date?: string;
  end_date?: string;
  sort_by?: 'timestamp' | 'temperature' | 'humidity' | 'precipitation';
  order?: 'asc' | 'desc';
  source?: WeatherSource;
}

export interface HourlyWeatherParams {
  lat?: number;
  lon?: number;
  days?: number;
}

export interface WeatherStats {
  avg_temperature: number;
  avg_humidity: number;
  total_precipitation: number;
  max_precipitation: number;
  record_count: number;
}

src/types/api/alert.ts
export interface Alert {
  id: number;
  risk_level: number;
  risk_label: string;
  location: string;
  message: string;
  delivery_status: AlertDeliveryStatus;
  prediction_id?: number;
  created_at: string;
  updated_at?: string;
}

export type AlertDeliveryStatus = 'pending' | 'delivered' | 'failed';

export interface AlertParams {
  limit?: number;
  offset?: number;
  risk_level?: number;
  status?: AlertDeliveryStatus;
  start_date?: string;
  end_date?: string;
}

export interface AlertHistory {
  alerts: Alert[];
  summary: {
    total: number;
    by_risk_level: Record<number, number>;
    by_status: Record<AlertDeliveryStatus, number>;
  };
  period: {
    start: string;
    end: string;
    days: number;
  };
}

export interface SSEAlertEvent {
  type: 'alert' | 'heartbeat' | 'connection';
  data: SSEAlertData | SSEHeartbeatData | SSEConnectionData;
}

export interface SSEAlertData {
  alert: Alert;
  timestamp: string;
}

export interface SSEHeartbeatData {
  timestamp: string;
  connections: number;
}

export interface SSEConnectionData {
  status: 'connected' | 'disconnected';
  client_id: string;
}

src/types/api/auth.ts
export interface LoginRequest {
  email: string;
  password: string;
}

export interface RegisterRequest {
  email: string;
  password: string;
  name: string;
}

export interface TokenResponse {
  access_token: string;
  refresh_token: string;
  token_type: 'Bearer';
  expires_in: number;
}

export interface RefreshTokenRequest {
  refresh_token: string;
}

export interface User {
  id: number;
  email: string;
  name: string;
  role: UserRole;
  is_active: boolean;
  created_at: string;
  updated_at?: string;
}

export type UserRole = 'user' | 'admin';

export interface ChangePasswordRequest {
  current_password: string;
  new_password: string;
}

export interface UpdateProfileRequest {
  name?: string;
  email?: string;
}

src/types/api/index.ts
export * from './common';
export * from './prediction';
export * from './weather';
export * from './alert';
export * from './auth';

8. State Management

src/state/stores/authStore.ts
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import type { User } from '@/types/api';

interface AuthState {
  user: User | null;
  accessToken: string | null;
  refreshToken: string | null;
  isAuthenticated: boolean;

  setAuth: (user: User, accessToken: string, refreshToken: string) => void;
  setAccessToken: (token: string) => void;
  setUser: (user: User) => void;
  clearAuth: () => void;
}

export const useAuthStore = create<AuthState>()(
  persist(
    (set) => ({
      user: null,
      accessToken: null,
      refreshToken: null,
      isAuthenticated: false,

      setAuth: (user, accessToken, refreshToken) =>
        set({
          user,
          accessToken,
          refreshToken,
          isAuthenticated: true,
        }),

      setAccessToken: (accessToken) => set({ accessToken }),

      setUser: (user) => set({ user }),

      clearAuth: () =>
        set({
          user: null,
          accessToken: null,
          refreshToken: null,
          isAuthenticated: false,
        }),
    }),
    {
      name: 'floodingnaque-auth',
      storage: createJSONStorage(() => localStorage),
      partialize: (state) => ({
        user: state.user,
        accessToken: state.accessToken,
        refreshToken: state.refreshToken,
        isAuthenticated: state.isAuthenticated,
      }),
    }
  )
);

src/state/stores/alertStore.ts
import { create } from 'zustand';
import type { Alert } from '@/types/api';

interface AlertState {
  liveAlerts: Alert[];
  unreadCount: number;
  isConnected: boolean;
  lastUpdate: string | null;
  connectionError: string | null;

  addAlert: (alert: Alert) => void;
  markAllRead: () => void;
  clearAlerts: () => void;
  setConnected: (connected: boolean) => void;
  setLastUpdate: (timestamp: string) => void;
  setConnectionError: (error: string | null) => void;
}

export const useAlertStore = create<AlertState>((set) => ({
  liveAlerts: [],
  unreadCount: 0,
  isConnected: false,
  lastUpdate: null,
  connectionError: null,

  addAlert: (alert) =>
    set((state) => ({
      liveAlerts: [alert, ...state.liveAlerts].slice(0, 100),
      unreadCount: state.unreadCount + 1,
      lastUpdate: new Date().toISOString(),
    })),

  markAllRead: () => set({ unreadCount: 0 }),

  clearAlerts: () => set({ liveAlerts: [], unreadCount: 0 }),

  setConnected: (isConnected) =>
    set({ isConnected, connectionError: isConnected ? null : undefined }),

  setLastUpdate: (lastUpdate) => set({ lastUpdate }),

  setConnectionError: (connectionError) => set({ connectionError, isConnected: false }),
}));

src/state/stores/uiStore.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface UIState {
  sidebarOpen: boolean;
  sidebarCollapsed: boolean;
  mobileMenuOpen: boolean;
  theme: 'light' | 'dark';

  toggleSidebar: () => void;
  setSidebarOpen: (open: boolean) => void;
  toggleSidebarCollapsed: () => void;
  setMobileMenuOpen: (open: boolean) => void;
  setTheme: (theme: 'light' | 'dark') => void;
  toggleTheme: () => void;
}

export const useUIStore = create<UIState>()(
  persist(
    (set) => ({
      sidebarOpen: true,
      sidebarCollapsed: false,
      mobileMenuOpen: false,
      theme: 'light',

      toggleSidebar: () => set((state) => ({ sidebarOpen: !state.sidebarOpen })),

      setSidebarOpen: (sidebarOpen) => set({ sidebarOpen }),

      toggleSidebarCollapsed: () =>
        set((state) => ({ sidebarCollapsed: !state.sidebarCollapsed })),

      setMobileMenuOpen: (mobileMenuOpen) => set({ mobileMenuOpen }),
      
      setTheme: (theme) => set({ theme }),
      
      toggleTheme: () => set((state) => ({ theme: state.theme === 'light' ? 'dark' : 'light' })),
    }),
    {
      name: 'floodingnaque-ui',
      partialize: (state) => ({ 
        sidebarCollapsed: state.sidebarCollapsed,
        theme: state.theme
      }),
    }
  )
);

9. API Integration

src/config/api.config.ts
const getEnvVar = (key: string, fallback: string): string => {
  return import.meta.env[key] || fallback;
};

export const API_CONFIG = {
  baseUrl: getEnvVar('VITE_API_BASE_URL', 'http://localhost:5000'),
  sseUrl: getEnvVar('VITE_SSE_URL', 'http://localhost:5000/api/v1/sse'),
  timeout: 30000,

  // API version prefix - all versioned endpoints use this
  apiPrefix: '/api/v1',

  endpoints: {
    // Health (no prefix - infrastructure endpoints)
    root: '/',
    status: '/status',
    health: '/health',
    healthLive: '/health/live',
    healthReady: '/health/ready',

    // Prediction (API v1)
    predict: '/api/v1/predict/predict',

    // Ingest (API v1)
    ingest: '/api/v1/ingest/ingest',

    // Data / Weather (API v1)
    data: '/api/v1/data/data',
    dataById: (id: number) => `/api/v1/data/data/${id}`,
    weatherHourly: '/api/v1/data/weather/hourly',
    meteostatStations: '/api/v1/data/meteostat/stations',
    meteostatDaily: '/api/v1/data/meteostat/daily',
    meteostatCurrent: '/api/v1/data/meteostat/current',
    meteostatStatus: '/api/v1/data/meteostat/status',

    // Alerts (API v1)
    alerts: '/api/v1/alerts',
    alertById: (id: number) => `/api/v1/alerts/${id}`,
    alertHistory: '/api/v1/alerts/history',
    alertRecent: '/api/v1/alerts/recent',
    alertStats: '/api/v1/alerts/stats',

    // Auth (API v1 - uses /auth prefix)
    login: '/api/v1/auth/login',
    register: '/api/v1/auth/register',
    refresh: '/api/v1/auth/refresh',
    logout: '/api/v1/auth/logout',
    profile: '/api/v1/auth/me',
    passwordResetRequest: '/api/v1/auth/password-reset/request',
    passwordResetConfirm: '/api/v1/auth/password-reset/confirm',

    // Webhooks (API v1)
    webhookRegister: '/api/v1/webhooks/register',
    webhookList: '/api/v1/webhooks/list',
    webhookById: (id: number) => `/api/v1/webhooks/${id}`,
    webhookToggle: (id: number) => `/api/v1/webhooks/${id}/toggle`,
    webhookTest: (id: number) => `/api/v1/webhooks/${id}/test`,
    webhookReset: (id: number) => `/api/v1/webhooks/${id}/reset`,
    webhookTrigger: '/api/v1/webhooks/trigger',
    webhookConfig: '/api/v1/webhooks/config',

    // SSE (API v1)
    sseAlerts: '/api/v1/sse/alerts',

    // Export (API v1)
    exportWeather: '/api/v1/export/weather',
    exportPredictions: '/api/v1/export/predictions',

    // Dashboard (API v1)
    dashboardSummary: '/api/v1/dashboard/summary',
    dashboardStats: '/api/v1/dashboard/statistics',
    dashboardActivity: '/api/v1/dashboard/activity',

    // Predictions History (API v1)
    predictions: '/api/v1/predictions',
    predictionById: (id: number) => `/api/v1/predictions/${id}`,
    predictionsRecent: '/api/v1/predictions/recent',
    predictionsStats: '/api/v1/predictions/stats',
    predictionsBulkDelete: '/api/v1/predictions/bulk-delete',

    // Tides (API v1)
    tidesCurrent: '/api/v1/tides/tides/current',
    tidesExtremes: '/api/v1/tides/tides/extremes',
    tidesPrediction: '/api/v1/tides/tides/prediction',
    tidesStatus: '/api/v1/tides/tides/status',

    // Models (API v1)
    modelsVersion: '/api/v1/models/api/version',
    modelsList: '/api/v1/models/api/models',
    modelsDocs: '/api/v1/models/api/docs',

    // Batch operations (API v1)
    batchPredict: '/api/v1/batch/predict',
  },
} as const;

src/lib/api-client.ts
import axios, { AxiosError, AxiosInstance, InternalAxiosRequestConfig } from 'axios';
import { API_CONFIG } from '@/config/api.config';
import { useAuthStore } from '@/state/stores/authStore';
import type { ApiError, ApiResponse } from '@/types/api';

const apiClient: AxiosInstance = axios.create({
  baseURL: API_CONFIG.baseUrl,
  timeout: API_CONFIG.timeout,
  headers: {
    'Content-Type': 'application/json',
    Accept: 'application/json',
  },
});

// Request interceptor
apiClient.interceptors.request.use(
  (config: InternalAxiosRequestConfig) => {
    const { accessToken } = useAuthStore.getState();

    if (accessToken) {
      config.headers.Authorization = `Bearer ${accessToken}`;
    }

    return config;
  },
  (error) => Promise.reject(error)
);

// Response interceptor
apiClient.interceptors.response.use(
  (response) => response,
  async (error: AxiosError<ApiError>) => {
    const originalRequest = error.config;

    // Handle 401 - attempt token refresh
    if (
      error.response?.status === 401 &&
      originalRequest &&
      !originalRequest.headers['X-Retry']
    ) {
      const { refreshToken, setAccessToken, clearAuth } = useAuthStore.getState();

      if (refreshToken) {
        try {
          const response = await axios.post(
            `${API_CONFIG.baseUrl}${API_CONFIG.endpoints.refresh}`,
            { refresh_token: refreshToken }
          );

          const { access_token } = response.data;
          setAccessToken(access_token);

          originalRequest.headers.Authorization = `Bearer ${access_token}`;
          originalRequest.headers['X-Retry'] = 'true';
          return apiClient(originalRequest);
        } catch {
          clearAuth();
          window.location.href = '/login';
        }
      } else {
        clearAuth();
        window.location.href = '/login';
      }
    }

    // Handle rate limiting
    if (error.response?.status === 429) {
      const retryAfter = error.response.headers['retry-after'] || 60;
      console.warn(`Rate limited. Retry after ${retryAfter} seconds.`);
    }

    return Promise.reject(error);
  }
);

export default apiClient;

// Typed helper methods
export const api = {
  get: <T>(url: string, params?: Record<string, unknown>): Promise<T> =>
    apiClient.get<T>(url, { params }).then((res) => res.data),

  post: <T>(url: string, data?: unknown): Promise<T> =>
    apiClient.post<T>(url, data).then((res) => res.data),

  put: <T>(url: string, data?: unknown): Promise<T> =>
    apiClient.put<T>(url, data).then((res) => res.data),

  patch: <T>(url: string, data?: unknown): Promise<T> =>
    apiClient.patch<T>(url, data).then((res) => res.data),

  delete: <T>(url: string): Promise<T> => apiClient.delete<T>(url).then((res) => res.data),
};

src/lib/cn.ts
import { type ClassValue, clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

src/lib/utils.ts
import { format, formatDistanceToNow, parseISO } from 'date-fns';

export function formatDate(date: string | Date, formatStr = 'PPP'): string {
  const d = typeof date === 'string' ? parseISO(date) : date;
  return format(d, formatStr);
}

export function formatDateTime(date: string | Date): string {
  return formatDate(date, 'PPP p');
}

export function formatRelativeTime(date: string | Date): string {
  const d = typeof date === 'string' ? parseISO(date) : date;
  return formatDistanceToNow(d, { addSuffix: true });
}

export function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

export function truncate(str: string, length: number): string {
  if (str.length <= length) return str;
  return str.slice(0, length) + '...';
}

export function generateId(): string {
  return Math.random().toString(36).substring(2, 9);
}

10. Authentication

src/features/auth/services/authApi.ts
import { api } from '@/lib/api-client';
import { API_CONFIG } from '@/config/api.config';
import type {
  LoginRequest,
  RegisterRequest,
  TokenResponse,
  User,
  ChangePasswordRequest,
  UpdateProfileRequest,
} from '@/types/api';

export const authApi = {
  login: (credentials: LoginRequest): Promise<TokenResponse> =>
    api.post(API_CONFIG.endpoints.login, credentials),

  register: (data: RegisterRequest): Promise<TokenResponse> =>
    api.post(API_CONFIG.endpoints.register, data),

  refresh: (refreshToken: string): Promise<{ access_token: string }> =>
    api.post(API_CONFIG.endpoints.refresh, { refresh_token: refreshToken }),

  getProfile: (): Promise<User> => api.get(API_CONFIG.endpoints.profile),

  updateProfile: (data: UpdateProfileRequest): Promise<User> =>
    api.patch(API_CONFIG.endpoints.profile, data),

  changePassword: (data: ChangePasswordRequest): Promise<void> =>
    api.post(API_CONFIG.endpoints.changePassword, data),
};

src/features/auth/hooks/useAuth
### src/features/auth/hooks/useAuth.ts

```typescript
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { useNavigate } from 'react-router-dom';
import { useAuthStore } from '@/state/stores/authStore';
import { authApi } from '../services/authApi';
import type { LoginRequest, RegisterRequest, ChangePasswordRequest, UpdateProfileRequest } from '@/types/api';

export function useAuth() {
  const navigate = useNavigate();
  const queryClient = useQueryClient();
  const { user, isAuthenticated, setAuth, clearAuth } = useAuthStore();

  // Login mutation
  const loginMutation = useMutation({
    mutationFn: authApi.login,
    onSuccess: async (data) => {
      // Fetch user profile after login
      const userProfile = await authApi.getProfile();
      setAuth(userProfile, data.access_token, data.refresh_token);
      navigate('/');
    },
  });

  // Registration mutation
  const registerMutation = useMutation({
    mutationFn: authApi.register,
    onSuccess: async (data) => {
      const userProfile = await authApi.getProfile();
      setAuth(userProfile, data.access_token, data.refresh_token);
      navigate('/');
    },
  });

  // Logout function
  const logout = () => {
    clearAuth();
    queryClient.clear();
    navigate('/login');
  };

  // Profile query
  const { data: profile, isLoading: isProfileLoading } = useQuery({
    queryKey: ['profile'],
    queryFn: authApi.getProfile,
    enabled: isAuthenticated,
    staleTime: 5 * 60 * 1000, // 5 minutes
  });

  // Update profile mutation
  const updateProfileMutation = useMutation({
    mutationFn: (data: UpdateProfileRequest) => authApi.updateProfile(data),
    onSuccess: (updatedUser) => {
      // Update the store with new user data
      useAuthStore.setState({ user: updatedUser });
      queryClient.setQueryData(['profile'], updatedUser);
    },
  });

  // Change password mutation
  const changePasswordMutation = useMutation({
    mutationFn: (data: ChangePasswordRequest) => authApi.changePassword(data),
  });

  return {
    user: profile || user,
    isAuthenticated,
    login: loginMutation.mutate,
    register: registerMutation.mutate,
    logout,
    updateProfile: updateProfileMutation.mutate,
    changePassword: changePasswordMutation.mutate,
    isLoggingIn: loginMutation.isPending,
    isRegistering: registerMutation.isPending,
    isUpdatingProfile: updateProfileMutation.isPending,
    isChangingPassword: changePasswordMutation.isPending,
    loginError: loginMutation.error,
    registerError: registerMutation.error,
    updateProfileError: updateProfileMutation.error,
    changePasswordError: changePasswordMutation.error,
    isProfileLoading,
  };
}

src/features/auth/components/ProtectedRoute.tsx
import { Navigate, Outlet, useLocation } from 'react-router-dom';
import { useAuthStore } from '@/state/stores/authStore';

export function ProtectedRoute() {
  const { isAuthenticated } = useAuthStore();
  const location = useLocation();

  if (!isAuthenticated) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  return <Outlet />;
}

src/features/auth/components/LoginForm.tsx
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { useAuth } from '../hooks/useAuth';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { useToast } from '@/hooks/useToast';

const loginSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
});

type LoginFormData = z.infer<typeof loginSchema>;

export function LoginForm() {
  const { login, isLoggingIn, loginError } = useAuth();
  const { toast } = useToast();
  
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<LoginFormData>({
    resolver: zodResolver(loginSchema),
  });

  const onSubmit = (data: LoginFormData) => {
    login(data);
  };

  return (
    <Card className="w-full max-w-md mx-auto">
      <CardHeader>
        <CardTitle className="text-2xl text-center">Sign In</CardTitle>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="email">Email</Label>
            <Input
              id="email"
              type="email"
              placeholder="you@example.com"
              {...register('email')}
              disabled={isLoggingIn}
            />
            {errors.email && (
              <p className="text-sm text-destructive">{errors.email.message}</p>
            )}
          </div>

          <div className="space-y-2">
            <Label htmlFor="password">Password</Label>
            <Input
              id="password"
              type="password"
              {...register('password')}
              disabled={isLoggingIn}
            />
            {errors.password && (
              <p className="text-sm text-destructive">{errors.password.message}</p>
            )}
          </div>

          {loginError && (
            <p className="text-sm text-destructive text-center">
              Invalid email or password
            </p>
          )}

          <Button type="submit" className="w-full" disabled={isLoggingIn}>
            {isLoggingIn ? 'Signing in...' : 'Sign In'}
          </Button>
        </form>
      </CardContent>
    </Card>
  );
}

src/features/auth/components/RegisterForm.tsx
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { useAuth } from '../hooks/useAuth';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';

const registerSchema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters'),
  email: z.string().email('Invalid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
});

type RegisterFormData = z.infer<typeof registerSchema>;

export function RegisterForm() {
  const { register, isRegistering, registerError } = useAuth();
  
  const {
    register: registerField,
    handleSubmit,
    formState: { errors },
  } = useForm<RegisterFormData>({
    resolver: zodResolver(registerSchema),
  });

  const onSubmit = (data: RegisterFormData) => {
    register(data);
  };

  return (
    <Card className="w-full max-w-md mx-auto">
      <CardHeader>
        <CardTitle className="text-2xl text-center">Create Account</CardTitle>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="name">Full Name</Label>
            <Input
              id="name"
              type="text"
              placeholder="John Doe"
              {...registerField('name')}
              disabled={isRegistering}
            />
            {errors.name && (
              <p className="text-sm text-destructive">{errors.name.message}</p>
            )}
          </div>

          <div className="space-y-2">
            <Label htmlFor="email">Email</Label>
            <Input
              id="email"
              type="email"
              placeholder="you@example.com"
              {...registerField('email')}
              disabled={isRegistering}
            />
            {errors.email && (
              <p className="text-sm text-destructive">{errors.email.message}</p>
            )}
          </div>

          <div className="space-y-2">
            <Label htmlFor="password">Password</Label>
            <Input
              id="password"
              type="password"
              {...registerField('password')}
              disabled={isRegistering}
            />
            {errors.password && (
              <p className="text-sm text-destructive">{errors.password.message}</p>
            )}
          </div>

          {registerError && (
            <p className="text-sm text-destructive text-center">
              Registration failed. Please try again.
            </p>
          )}

          <Button type="submit" className="w-full" disabled={isRegistering}>
            {isRegistering ? 'Creating account...' : 'Create Account'}
          </Button>
        </form>
      </CardContent>
    </Card>
  );
}

11. Real-time Features

src/features/alerts/hooks/useAlertStream.ts
import { useEffect, useRef, useCallback } from 'react';
import { useAlertStore } from '@/state/stores/alertStore';
import { API_CONFIG } from '@/config/api.config';
import type { Alert, SSEAlertEvent } from '@/types/api';

interface UseAlertStreamOptions {
  enabled?: boolean;
  onAlert?: (alert: Alert) => void;
  onError?: (error: Event) => void;
}

export function useAlertStream(options: UseAlertStreamOptions = {}) {
  const { enabled = true, onAlert, onError } = options;
  const eventSourceRef = useRef<EventSource | null>(null);
  const reconnectTimeoutRef = useRef<NodeJS.Timeout>();
  const reconnectAttempts = useRef(0);
  
  const { addAlert, setConnected, setLastUpdate, setConnectionError } = useAlertStore();

  const connect = useCallback(() => {
    if (eventSourceRef.current) {
      eventSourceRef.current.close();
    }

    const url = `${API_CONFIG.sseUrl}/alerts`;
    const eventSource = new EventSource(url);
    eventSourceRef.current = eventSource;

    eventSource.onopen = () => {
      console.log('SSE connected');
      setConnected(true);
      setConnectionError(null);
      reconnectAttempts.current = 0;
    };

    eventSource.addEventListener('alert', (event) => {
      try {
        const data = JSON.parse(event.data) as SSEAlertEvent;
        if (data.type === 'alert') {
          addAlert(data.data as Alert);
          onAlert?.(data.data as Alert);
        }
      } catch (error) {
        console.error('Failed to parse alert:', error);
      }
    });

    eventSource.addEventListener('heartbeat', (event) => {
      try {
        const data = JSON.parse(event.data);
        setLastUpdate(data.timestamp);
      } catch (error) {
        console.error('Failed to parse heartbeat:', error);
      }
    });

    eventSource.onerror = (error) => {
      console.error('SSE error:', error);
      setConnected(false);
      setConnectionError('Connection lost');
      onError?.(error);
      
      // Exponential backoff reconnection
      const delay = Math.min(1000 * 2 ** reconnectAttempts.current, 30000);
      reconnectAttempts.current++;
      
      reconnectTimeoutRef.current = setTimeout(() => {
        if (enabled) connect();
      }, delay);
    };
  }, [enabled, addAlert, setConnected, setLastUpdate, setConnectionError, onAlert, onError]);

  const disconnect = useCallback(() => {
    if (eventSourceRef.current) {
      eventSourceRef.current.close();
      eventSourceRef.current = null;
    }
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
    }
    setConnected(false);
    setConnectionError(null);
  }, [setConnected, setConnectionError]);

  useEffect(() => {
    if (enabled) {
      connect();
    }
    
    return () => {
      disconnect();
    };
  }, [enabled, connect, disconnect]);

  return {
    connect,
    disconnect,
    isConnected: useAlertStore((state) => state.isConnected),
    connectionError: useAlertStore((state) => state.connectionError),
    liveAlerts: useAlertStore((state) => state.liveAlerts),
    unreadCount: useAlertStore((state) => state.unreadCount),
    markAllRead: useAlertStore.getState().markAllRead,
  };
}

src/components/feedback/ConnectionStatus.tsx
import { useEffect, useState } from 'react';
import { useAlertStore } from '@/state/stores/alertStore';
import { Badge } from '@/components/ui/badge';
import { AlertTriangle, Wifi, WifiOff } from 'lucide-react';

export function ConnectionStatus() {
  const isConnected = useAlertStore((state) => state.isConnected);
  const connectionError = useAlertStore((state) => state.connectionError);
  const [isOnline, setIsOnline] = useState(navigator.onLine);

  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  if (!isOnline) {
    return (
      <Badge variant="destructive" className="flex items-center gap-1">
        <WifiOff className="h-3 w-3" />
        Offline
      </Badge>
    );
  }

  if (connectionError) {
    return (
      <Badge variant="destructive" className="flex items-center gap-1">
        <AlertTriangle className="h-3 w-3" />
        Disconnected
      </Badge>
    );
  }

  return (
    <Badge variant={isConnected ? "default" : "secondary"} className="flex items-center gap-1">
      <Wifi className={`h-3 w-3 ${isConnected ? 'text-green-500' : 'text-yellow-500'}`} />
      {isConnected ? 'Connected' : 'Connecting...'}
    </Badge>
  );
}

12. UI Components

### 12.5 Responsive Design

#### Breakpoint Reference

| Breakpoint | Width | Purpose |
|------------|-------|---------|
| `sm` | 640px | Small devices (phones) |
| `md` | 768px | Medium devices (tablets) |
| `lg` | 1024px | Large devices (desktops) |
| `xl` | 1280px | Extra large devices |
| `2xl` | 1536px | Extra extra large devices |

#### Mobile-First Approach

We follow a mobile-first design philosophy where base styles target mobile devices, with progressive enhancement for larger screens:

```typescript
// Mobile styles first, desktop enhancements with media queries
const ResponsiveComponent = () => (
  <div className="block md:hidden">
    {/* Mobile-only content */}
  </div>
  <div className="hidden md:block">
    {/* Desktop-only content */}
  </div>
);
```

#### useMediaQuery Hook

```typescript
// src/hooks/useMediaQuery.ts
import { useState, useEffect } from 'react';

export function useMediaQuery(query: string): boolean {
  const [matches, setMatches] = useState(false);

  useEffect(() => {
    const media = window.matchMedia(query);
    if (media.matches !== matches) {
      setMatches(media.matches);
    }
    const listener = () => setMatches(media.matches);
    media.addListener(listener);
    return () => media.removeListener(listener);
  }, [matches, query]);

  return matches;
}

// Usage
const isDesktop = useMediaQuery('(min-width: 768px)');
```

#### Component Swapping Pattern

Implement responsive component variations using conditional rendering:

```tsx
// src/components/layout/MobileNav.tsx
import { Sheet, SheetContent, SheetTrigger } from '@/components/ui/sheet';
import { Button } from '@/components/ui/button';
import { Menu } from 'lucide-react';

export function MobileNav() {
  return (
    <Sheet>
      <SheetTrigger asChild>
        <Button variant="ghost" size="icon" className="md:hidden">
          <Menu className="h-5 w-5" />
        </Button>
      </SheetTrigger>
      <SheetContent side="left" className="w-64">
        {/* Navigation content */}
      </SheetContent>
    </Sheet>
  );
}
```

```tsx
// Conditional component rendering
import { Sidebar } from './Sidebar';
import { MobileNav } from './MobileNav';

export function Navigation() {
  const isDesktop = useMediaQuery('(min-width: 768px)');

  return (
    <>
      {isDesktop ? <Sidebar /> : <MobileNav />}
    </>
  );
}
```

#### Responsive Utilities

Common responsive patterns using Tailwind:

```tsx
// Grid layouts that adapt to screen size
<div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
  {/* Grid items */}
</div>

// Text sizing that scales appropriately
<h1 className="text-2xl sm:text-3xl md:text-4xl">Responsive Heading</h1>

// Spacing that adapts to screen size
<div className="p-4 sm:p-6 md:p-8">Content</div>
```

#### Touch-Friendly Interactions

Ensure touch targets are appropriately sized for mobile devices:

```tsx
// Minimum touch target size (44px)
<Button className="h-11 w-11 sm:h-10 sm:w-10">Button</Button>
```

#### Performance Considerations

- Minimize re-renders on resize events by debouncing media query changes
- Lazy-load components not visible on mobile
- Optimize images for different screen densities

src/components/ui/button.tsx
import * as React from 'react';
import { Slot } from '@radix-ui/react-slot';
import { cva, type VariantProps } from 'class-variance-authority';
import { cn } from '@/lib/cn';

const buttonVariants = cva(
  'inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50',
  {
    variants: {
      variant: {
        default: 'bg-primary text-primary-foreground hover:bg-primary/90',
        destructive: 'bg-destructive text-destructive-foreground hover:bg-destructive/90',
        outline: 'border border-input bg-background hover:bg-accent hover:text-accent-foreground',
        secondary: 'bg-secondary text-secondary-foreground hover:bg-secondary/80',
        ghost: 'hover:bg-accent hover:text-accent-foreground',
        link: 'text-primary underline-offset-4 hover:underline',
      },
      size: {
        default: 'h-10 px-4 py-2',
        sm: 'h-9 rounded-md px-3',
        lg: 'h-11 rounded-md px-8',
        icon: 'h-10 w-10',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : 'button';
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  }
);
Button.displayName = 'Button';

export { Button, buttonVariants };

src/components/ui/card.tsx
import * as React from 'react';
import { cn } from '@/lib/cn';

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      'rounded-lg border bg-card text-card-foreground shadow-sm',
      className
    )}
    {...props}
  />
));
Card.displayName = 'Card';

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn('flex flex-col space-y-1.5 p-6', className)}
    {...props}
  />
));
CardHeader.displayName = 'CardHeader';

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      'text-2xl font-semibold leading-none tracking-tight',
      className
    )}
    {...props}
  />
));
CardTitle.displayName = 'CardTitle';

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn('text-sm text-muted-foreground', className)}
    {...props}
  />
));
CardDescription.displayName = 'CardDescription';

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn('p-6 pt-0', className)} {...props} />
));
CardContent.displayName = 'CardContent';

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn('flex items-center p-6 pt-0', className)}
    {...props}
  />
));
CardFooter.displayName = 'CardFooter';

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent };

src/components/ui/input.tsx
import * as React from 'react';
import { cn } from '@/lib/cn';

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          'flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50',
          className
        )}
        ref={ref}
        {...props}
      />
    );
  }
);
Input.displayName = 'Input';

export { Input };

src/components/ui/label.tsx
import * as React from 'react';
import * as LabelPrimitive from '@radix-ui/react-label';
import { cva, type VariantProps } from 'class-variance-authority';
import { cn } from '@/lib/cn';

const labelVariants = cva(
  'text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70'
);

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };

src/components/ui/toast.tsx
import * as React from 'react';
import * as ToastPrimitives from '@radix-ui/react-toast';
import { cva, type VariantProps } from 'class-variance-authority';
import { X } from 'lucide-react';
import { cn } from '@/lib/cn';

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      'fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]',
      className
    )}
    {...props}
  />
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
  'group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full',
  {
    variants: {
      variant: {
        default: 'border bg-background text-foreground',
        destructive:
          'destructive group border-destructive bg-destructive text-destructive-foreground',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  }
);

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  );
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      'inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive',
      className
    )}
    {...props}
  />
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      'absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600',
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn('text-sm font-semibold', className)}
    {...props}
  />
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn('text-sm opacity-90', className)}
    {...props}
  />
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
};

src/components/ui/toaster.tsx
import { useToast } from '@/hooks/useToast';
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from '@/components/ui/toast';

export function Toaster() {
  const { toasts } = useToast();

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        );
      })}
      <ToastViewport />
    </ToastProvider>
  );
}

src/hooks/useToast.ts
import * as React from 'react';

import type { ToastActionElement, ToastProps } from '@/components/ui/toast';

const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1000000;

type ToasterToast = ToastProps & {
  id: string;
  title?: React.ReactNode;
  description?: React.ReactNode;
  action?: ToastActionElement;
};

const actionTypes = {
  ADD_TOAST: 'ADD_TOAST',
  UPDATE_TOAST: 'UPDATE_TOAST',
  DISMISS_TOAST: 'DISMISS_TOAST',
  REMOVE_TOAST: 'REMOVE_TOAST',
} as const;

let count = 0;

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER;
  return count.toString();
}

type ActionType = typeof actionTypes;

type Action =
  | {
      type: ActionType['ADD_TOAST'];
      toast: ToasterToast;
    }
  | {
      type: ActionType['UPDATE_TOAST'];
      toast: Partial<ToasterToast>;
    }
  | {
      type: ActionType['DISMISS_TOAST'];
      toastId?: ToasterToast['id'];
    }
  | {
      type: ActionType['REMOVE_TOAST'];
      toastId?: ToasterToast['id'];
    };

interface State {
  toasts: ToasterToast[];
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return;
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId);
    dispatch({
      type: 'REMOVE_TOAST',
      toastId: toastId,
    });
  }, TOAST_REMOVE_DELAY);

  toastTimeouts.set(toastId, timeout);
};

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case 'ADD_TOAST':
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      };

    case 'UPDATE_TOAST':
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      };

    case 'DISMISS_TOAST': {
      const { toastId } = action;

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId);
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id);
        });
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      };
    }
    case 'REMOVE_TOAST':
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        };
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      };
  }
};

const listeners: Array<(state: State) => void> = [];

let memoryState: State = { toasts: [] };

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action);
  listeners.forEach((listener) => {
    listener(memoryState);
  });
}

interface Toast extends Omit<ToasterToast, 'id'> {}

function toast({ ...props }: Toast) {
  const id = genId();

  const update = (props: Partial<ToasterToast>) =>
    dispatch({
      type: 'UPDATE_TOAST',
      toast: { ...props, id },
    });
  const dismiss = () => dispatch({ type: 'DISMISS_TOAST', toastId: id });

  dispatch({
    type: 'ADD_TOAST',
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss();
      },
    },
  });

  return {
    id: id,
    dismiss,
    update,
  };
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState);

  React.useEffect(() => {
    listeners.push(setState);
    return () => {
      const index = listeners.indexOf(setState);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  }, [state]);

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: 'DISMISS_TOAST', toastId }),
  };
}

export { useToast, toast };

13. Feature Modules

src/features/flooding/services/predictionApi.ts
import { api } from '@/lib/api-client';
import { API_CONFIG } from '@/config/api.config';
import type { PredictionRequest, PredictionResponse } from '@/types/api';

export const predictionApi = {
  predict: async (data: PredictionRequest): Promise<PredictionResponse> => {
    return api.post<PredictionResponse>(
      `${API_CONFIG.endpoints.predict}?risk_level=true&return_proba=true`,
      data
    );
  },

  getHistory: async (params?: { limit?: number; offset?: number }): Promise<any> => {
    return api.get(API_CONFIG.endpoints.data, params);
  },
};

src/features/flooding/hooks/usePrediction.ts
import { useMutation } from '@tanstack/react-query';
import { predictionApi } from '../services/predictionApi';
import type { PredictionRequest, PredictionResponse } from '@/types/api';

export function usePrediction() {
  return useMutation<PredictionResponse, Error, PredictionRequest>({
    mutationFn: predictionApi.predict,
  });
}

src/features/flooding/components/PredictionForm.tsx
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { usePrediction } from '../hooks/usePrediction';
import { celsiusToKelvin } from '../utils/temperature';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { RiskDisplay } from './RiskDisplay';
import { useToast } from '@/hooks/useToast';

const predictionSchema = z.object({
  temperature: z.number().min(-50).max(60), // Celsius input
  humidity: z.number().min(0).max(100),
  precipitation: z.number().min(0),
  wind_speed: z.number().min(0).optional(),
  pressure: z.number().min(800).max(1200).optional(),
});

type PredictionFormData = z.infer<typeof predictionSchema>;

export function PredictionForm() {
  const { mutate: predict, data: result, isPending, error } = usePrediction();
  const { toast } = useToast();
  
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<PredictionFormData>({
    resolver: zodResolver(predictionSchema),
    defaultValues: {
      temperature: 30,
      humidity: 70,
      precipitation: 10,
    },
  });

  const onSubmit = (data: PredictionFormData) => {
    predict({
      ...data,
      temperature: celsiusToKelvin(data.temperature), // Convert to Kelvin
    });
  };

  return (
    <div className="grid md:grid-cols-2 gap-6">
      <Card>
        <CardHeader>
          <CardTitle>Flood Risk Prediction</CardTitle>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="temperature">Temperature (°C)</Label>
              <Input
                id="temperature"
                type="number"
                step="0.1"
                {...register('temperature', { valueAsNumber: true })}
              />
              {errors.temperature && (
                <p className="text-sm text-destructive">{errors.temperature.message}</p>
              )}
            </div>

            <div className="space-y-2">
              <Label htmlFor="humidity">Humidity (%)</Label>
              <Input
                id="humidity"
                type="number"
                {...register('humidity', { valueAsNumber: true })}
              />
              {errors.humidity && (
                <p className="text-sm text-destructive">{errors.humidity.message}</p>
              )}
            </div>

            <div className="space-y-2">
              <Label htmlFor="precipitation">Precipitation (mm/hr)</Label>
              <Input
                id="precipitation"
                type="number"
                step="0.1"
                {...register('precipitation', { valueAsNumber: true })}
              />
              {errors.precipitation && (
                <p className="text-sm text-destructive">{errors.precipitation.message}</p>
              )}
            </div>

            <div className="space-y-2">
              <Label htmlFor="wind_speed">Wind Speed (m/s) - Optional</Label>
              <Input
                id="wind_speed"
                type="number"
                step="0.1"
                {...register('wind_speed', { valueAsNumber: true })}
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="pressure">Pressure (hPa) - Optional</Label>
              <Input
                id="pressure"
                type="number"
                {...register('pressure', { valueAsNumber: true })}
              />
            </div>

            {error && (
              <p className="text-sm text-destructive text-center">
                Prediction failed. Please try again.
              </p>
            )}

            <Button type="submit" className="w-full" disabled={isPending}>
              {isPending ? 'Predicting...' : 'Get Prediction'}
            </Button>
          </form>
        </CardContent>
      </Card>

      {result && (
        <div className="flex items-center justify-center">
          <RiskDisplay 
            riskLevel={result.risk_level} 
            probability={result.probability}
          />
        </div>
      )}
    </div>
  );
}

src/features/flooding/components/RiskDisplay.tsx
import { cn } from '@/lib/cn';
import { RISK_CONFIGS, type RiskLevel } from '@/types/api';
import { AlertTriangle, CheckCircle, XCircle } from 'lucide-react';

interface RiskDisplayProps {
  riskLevel: RiskLevel;
  probability?: number;
  className?: string;
}

const riskIcons = {
  0: CheckCircle,
  1: AlertTriangle,
  2: XCircle,
};

export function RiskDisplay({ riskLevel, probability, className }: RiskDisplayProps) {
  const config = RISK_CONFIGS[riskLevel];
  const Icon = riskIcons[riskLevel];

  return (
    <div
      className={cn(
        'rounded-lg p-6 text-white text-center max-w-sm',
        className
      )}
      style={{ backgroundColor: config.color }}
    >
      <Icon className="w-16 h-16 mx-auto mb-4" />
      <h2 className="text-3xl font-bold mb-2">{config.label}</h2>
      <p className="text-lg opacity-90">{config.description}</p>
      {probability !== undefined && (
        <p className="mt-4 text-2xl font-semibold">
          {(probability * 100).toFixed(1)}% probability
        </p>
      )}
    </div>
  );
}

src/features/flooding/utils/temperature.ts
/**
 * Temperature conversion utilities
 * Backend uses Kelvin; UI displays Celsius
 */

export function celsiusToKelvin(celsius: number): number {
  return celsius + 273.15;
}

export function kelvinToCelsius(kelvin: number): number {
  return kelvin - 273.15;
}

export function formatTemperature(kelvin: number, unit: 'C' | 'K' = 'C'): string {
  if (unit === 'K') {
    return `${kelvin.toFixed(1)} K`;
  }
  return `${kelvinToCelsius(kelvin).toFixed(1)}°C`;
}

### 13.2 Alerts Feature Module

src/features/alerts/services/alertsApi.ts
```typescript
import { api } from '@/lib/api-client';
import { API_CONFIG } from '@/config/api.config';
import type { Alert, AlertParams, AlertHistory } from '@/types/api';
import type { PaginatedResponse } from '@/types/api';

export const alertsApi = {
  getAlerts: async (params?: AlertParams): Promise<PaginatedResponse<Alert>> => {
    return api.get<PaginatedResponse<Alert>>(API_CONFIG.endpoints.alerts, params);
  },

  getAlertById: async (id: number): Promise<Alert> => {
    return api.get<Alert>(API_CONFIG.endpoints.alertById(id));
  },

  getAlertHistory: async (params?: AlertParams): Promise<AlertHistory[]> => {
    return api.get<AlertHistory[]>(API_CONFIG.endpoints.alertHistory, params);
  },

  getRecentAlerts: async (limit = 10): Promise<Alert[]> => {
    return api.get<Alert[]>(API_CONFIG.endpoints.alertRecent, { limit });
  },

  getAlertStats: async (): Promise<{
    total: number;
    by_level: Record<string, number>;
    by_status: Record<string, number>;
  }> => {
    return api.get(API_CONFIG.endpoints.alertStats);
  },
};
```

src/features/alerts/hooks/useAlerts.ts
```typescript
import { useQuery } from '@tanstack/react-query';
import { alertsApi } from '../services/alertsApi';
import type { AlertParams } from '@/types/api';

export function useAlerts(params?: AlertParams) {
  return useQuery({
    queryKey: ['alerts', params],
    queryFn: () => alertsApi.getAlerts(params),
    refetchInterval: 30000, // Refetch every 30 seconds
  });
}

export function useAlertById(id: number) {
  return useQuery({
    queryKey: ['alert', id],
    queryFn: () => alertsApi.getAlertById(id),
    enabled: !!id,
  });
}

export function useRecentAlerts(limit = 10) {
  return useQuery({
    queryKey: ['alerts', 'recent', limit],
    queryFn: () => alertsApi.getRecentAlerts(limit),
    refetchInterval: 15000, // More frequent for recent alerts
  });
}

export function useAlertStats() {
  return useQuery({
    queryKey: ['alerts', 'stats'],
    queryFn: () => alertsApi.getAlertStats(),
    staleTime: 60000, // Stats change less frequently
  });
}
```

src/features/alerts/components/AlertList.tsx
```typescript
import { useAlerts } from '../hooks/useAlerts';
import { AlertCard } from './AlertCard';
import { Skeleton } from '@/components/ui/skeleton';
import { AlertTriangle } from 'lucide-react';

interface AlertListProps {
  limit?: number;
  showFilters?: boolean;
}

export function AlertList({ limit = 10, showFilters = true }: AlertListProps) {
  const { data, isLoading, error } = useAlerts({ limit });

  if (isLoading) {
    return (
      <div className="space-y-4">
        {Array.from({ length: 3 }).map((_, i) => (
          <Skeleton key={i} className="h-24 w-full" />
        ))}
      </div>
    );
  }

  if (error) {
    return (
      <div className="text-center py-8 text-muted-foreground">
        <AlertTriangle className="w-8 h-8 mx-auto mb-2" />
        <p>Failed to load alerts</p>
      </div>
    );
  }

  if (!data?.data?.length) {
    return (
      <div className="text-center py-8 text-muted-foreground">
        <p>No alerts found</p>
      </div>
    );
  }

  return (
    <div className="space-y-4">
      {data.data.map((alert) => (
        <AlertCard key={alert.id} alert={alert} />
      ))}
    </div>
  );
}
```

src/features/alerts/components/AlertCard.tsx
```typescript
import { cn } from '@/lib/cn';
import { formatRelativeTime } from '@/lib/utils';
import { Card, CardContent } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { MapPin, Clock } from 'lucide-react';
import type { Alert } from '@/types/api';
import { RISK_CONFIGS } from '@/types/api';

interface AlertCardProps {
  alert: Alert;
  className?: string;
}

export function AlertCard({ alert, className }: AlertCardProps) {
  const config = RISK_CONFIGS[alert.risk_level as 0 | 1 | 2] || RISK_CONFIGS[0];

  return (
    <Card className={cn('border-l-4', className)} style={{ borderLeftColor: config.color }}>
      <CardContent className="p-4">
        <div className="flex items-start justify-between gap-4">
          <div className="flex-1 min-w-0">
            <div className="flex items-center gap-2 mb-2">
              <Badge 
                variant="outline" 
                style={{ 
                  borderColor: config.color, 
                  color: config.color 
                }}
              >
                {alert.risk_label}
              </Badge>
              <Badge variant={alert.delivery_status === 'delivered' ? 'default' : 'secondary'}>
                {alert.delivery_status}
              </Badge>
            </div>
            <p className="text-sm text-foreground mb-2">{alert.message}</p>
            <div className="flex items-center gap-4 text-xs text-muted-foreground">
              <span className="flex items-center gap-1">
                <MapPin className="w-3 h-3" />
                {alert.location}
              </span>
              <span className="flex items-center gap-1">
                <Clock className="w-3 h-3" />
                {formatRelativeTime(alert.created_at)}
              </span>
            </div>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
```

src/features/alerts/components/AlertBanner.tsx
```typescript
import { useRecentAlerts } from '../hooks/useAlerts';
import { useAlertStream } from '../hooks/useAlertStream';
import { cn } from '@/lib/cn';
import { AlertTriangle, X } from 'lucide-react';
import { useState } from 'react';
import { RISK_CONFIGS } from '@/types/api';

export function AlertBanner() {
  const [dismissed, setDismissed] = useState<number[]>([]);
  const { data: recentAlerts } = useRecentAlerts(1);
  
  // Enable real-time alert streaming
  useAlertStream({ enabled: true });

  const latestAlert = recentAlerts?.[0];
  
  if (!latestAlert || dismissed.includes(latestAlert.id)) {
    return null;
  }

  const config = RISK_CONFIGS[latestAlert.risk_level as 0 | 1 | 2] || RISK_CONFIGS[1];

  return (
    <div 
      className={cn(
        'fixed top-0 left-0 right-0 z-50 p-3',
        'flex items-center justify-between gap-4',
        'text-white shadow-lg'
      )}
      style={{ backgroundColor: config.color }}
    >
      <div className="flex items-center gap-3">
        <AlertTriangle className="w-5 h-5 flex-shrink-0" />
        <div>
          <span className="font-semibold">{latestAlert.risk_label}: </span>
          <span>{latestAlert.message}</span>
        </div>
      </div>
      <button
        onClick={() => setDismissed((prev) => [...prev, latestAlert.id])}
        className="p-1 hover:bg-white/20 rounded"
        aria-label="Dismiss alert"
      >
        <X className="w-4 h-4" />
      </button>
    </div>
  );
}
```

### 13.3 Weather Feature Module

src/features/weather/services/weatherApi.ts
```typescript
import { api } from '@/lib/api-client';
import { API_CONFIG } from '@/config/api.config';
import type { WeatherData, WeatherDataParams, HourlyWeatherParams, WeatherStats } from '@/types/api';
import type { PaginatedResponse } from '@/types/api';

export const weatherApi = {
  getWeatherData: async (params?: WeatherDataParams): Promise<PaginatedResponse<WeatherData>> => {
    return api.get<PaginatedResponse<WeatherData>>(API_CONFIG.endpoints.data, params);
  },

  getHourlyWeather: async (params?: HourlyWeatherParams): Promise<WeatherData[]> => {
    return api.get<WeatherData[]>(API_CONFIG.endpoints.weatherHourly, params);
  },

  getWeatherStats: async (startDate?: string, endDate?: string): Promise<WeatherStats> => {
    return api.get<WeatherStats>(`${API_CONFIG.endpoints.data}/stats`, {
      start_date: startDate,
      end_date: endDate,
    });
  },

  ingestWeatherData: async (data: Partial<WeatherData>[]): Promise<{ inserted: number }> => {
    return api.post(`${API_CONFIG.endpoints.ingest}`, { records: data });
  },
};
```

src/features/weather/hooks/useWeather.ts
```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { weatherApi } from '../services/weatherApi';
import type { WeatherDataParams, HourlyWeatherParams, WeatherData } from '@/types/api';

export function useWeatherData(params?: WeatherDataParams) {
  return useQuery({
    queryKey: ['weather', 'data', params],
    queryFn: () => weatherApi.getWeatherData(params),
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
}

export function useHourlyWeather(params?: HourlyWeatherParams) {
  return useQuery({
    queryKey: ['weather', 'hourly', params],
    queryFn: () => weatherApi.getHourlyWeather(params),
    staleTime: 15 * 60 * 1000, // 15 minutes
  });
}

export function useWeatherStats(startDate?: string, endDate?: string) {
  return useQuery({
    queryKey: ['weather', 'stats', startDate, endDate],
    queryFn: () => weatherApi.getWeatherStats(startDate, endDate),
    staleTime: 30 * 60 * 1000, // 30 minutes
  });
}

export function useIngestWeather() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data: Partial<WeatherData>[]) => weatherApi.ingestWeatherData(data),
    onSuccess: () => {
      // Invalidate weather queries to refetch
      queryClient.invalidateQueries({ queryKey: ['weather'] });
    },
  });
}
```

src/features/weather/components/WeatherCard.tsx
```typescript
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { kelvinToCelsius } from '@/features/flooding/utils/temperature';
import { Cloud, Droplets, Wind, Gauge } from 'lucide-react';
import type { WeatherData } from '@/types/api';

interface WeatherCardProps {
  data: WeatherData;
  showDetails?: boolean;
}

export function WeatherCard({ data, showDetails = false }: WeatherCardProps) {
  const tempCelsius = kelvinToCelsius(data.temperature);

  return (
    <Card>
      <CardHeader className="pb-2">
        <CardTitle className="text-lg flex items-center gap-2">
          <Cloud className="w-5 h-5" />
          Current Weather
        </CardTitle>
      </CardHeader>
      <CardContent>
        <div className="grid grid-cols-2 gap-4">
          <div className="text-center">
            <p className="text-3xl font-bold">{tempCelsius.toFixed(1)}°C</p>
            <p className="text-sm text-muted-foreground">Temperature</p>
          </div>
          <div className="text-center">
            <div className="flex items-center justify-center gap-1">
              <Droplets className="w-4 h-4 text-blue-500" />
              <p className="text-2xl font-semibold">{data.humidity}%</p>
            </div>
            <p className="text-sm text-muted-foreground">Humidity</p>
          </div>
          {showDetails && (
            <>
              <div className="text-center">
                <div className="flex items-center justify-center gap-1">
                  <Wind className="w-4 h-4 text-gray-500" />
                  <p className="text-xl">{data.wind_speed?.toFixed(1) || 'N/A'} m/s</p>
                </div>
                <p className="text-sm text-muted-foreground">Wind Speed</p>
              </div>
              <div className="text-center">
                <div className="flex items-center justify-center gap-1">
                  <Gauge className="w-4 h-4 text-purple-500" />
                  <p className="text-xl">{data.pressure?.toFixed(0) || 'N/A'} hPa</p>
                </div>
                <p className="text-sm text-muted-foreground">Pressure</p>
              </div>
            </>
          )}
        </div>
        <div className="mt-4 pt-4 border-t">
          <div className="flex items-center justify-center gap-1 text-blue-600">
            <Droplets className="w-5 h-5" />
            <p className="text-xl font-semibold">{data.precipitation} mm/hr</p>
          </div>
          <p className="text-sm text-muted-foreground text-center">Precipitation</p>
        </div>
      </CardContent>
    </Card>
  );
}
```

src/features/weather/components/WeatherHistory.tsx
```typescript
import { useWeatherData } from '../hooks/useWeather';
import { WeatherChart } from '@/components/charts/WeatherChart';
import { Skeleton } from '@/components/ui/skeleton';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { format } from 'date-fns';

interface WeatherHistoryProps {
  days?: number;
}

export function WeatherHistory({ days = 7 }: WeatherHistoryProps) {
  const endDate = new Date();
  const startDate = new Date();
  startDate.setDate(startDate.getDate() - days);

  const { data, isLoading, error } = useWeatherData({
    start_date: format(startDate, 'yyyy-MM-dd'),
    end_date: format(endDate, 'yyyy-MM-dd'),
    limit: 100,
  });

  if (isLoading) {
    return <Skeleton className="h-64 w-full" />;
  }

  if (error || !data?.data) {
    return (
      <Card>
        <CardContent className="p-6 text-center text-muted-foreground">
          Failed to load weather history
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>Weather History ({days} Days)</CardTitle>
      </CardHeader>
      <CardContent>
        <WeatherChart data={data.data} />
      </CardContent>
    </Card>
  );
}
```

14. Testing Strategy

src/tests/setup.ts
import { expect, afterEach } from 'vitest';
import { cleanup } from '@testing-library/react';
import matchers from '@testing-library/jest-dom/matchers';

expect.extend(matchers);

afterEach(() => {
  cleanup();
});

src/tests/test-utils.tsx
import { render } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { BrowserRouter } from 'react-router-dom';
import { ThemeProvider } from '@/providers/ThemeProvider';

const createTestQueryClient = () => {
  return new QueryClient({
    defaultOptions: {
      queries: {
        retry: false,
        cacheTime: 0,
      },
    },
  });
};

interface AllTheProvidersProps {
  children: React.ReactNode;
}

const AllTheProviders = ({ children }: AllTheProvidersProps) => {
  const testQueryClient = createTestQueryClient();
  return (
    <QueryClientProvider client={testQueryClient}>
      <ThemeProvider defaultTheme="light" storageKey="test-theme">
        <BrowserRouter>
          {children}
        </BrowserRouter>
      </ThemeProvider>
    </QueryClientProvider>
  );
};

const customRender = (ui: React.ReactElement, options = {}) =>
  render(ui, { wrapper: AllTheProviders, ...options });

export * from '@testing-library/react';
export { customRender as render };

src/tests/mocks/server.ts
import { setupServer } from 'msw/node';
import { handlers } from './handlers';

export const server = setupServer(...handlers);

src/tests/mocks/handlers.ts
import { http, HttpResponse } from 'msw';
import { API_CONFIG } from '@/config/api.config';
import { mockUsers, mockPredictions, mockAlerts } from './data';

export const handlers = [
  // Auth endpoints
  http.post(API_CONFIG.endpoints.login, () => {
    return HttpResponse.json({
      access_token: 'mock_access_token',
      refresh_token: 'mock_refresh_token',
      token_type: 'Bearer',
      expires_in: 3600,
    });
  }),

  http.get(API_CONFIG.endpoints.profile, () => {
    return HttpResponse.json(mockUsers[0]);
  }),

  // Prediction endpoints
  http.post(API_CONFIG.endpoints.predict, () => {
    return HttpResponse.json(mockPredictions[0]);
  }),

  // Alerts endpoints
  http.get(API_CONFIG.endpoints.alerts, () => {
    return HttpResponse.json({
      success: true,
      data: mockAlerts,
      total: mockAlerts.length,
      limit: 10,
      offset: 0,
      count: mockAlerts.length,
      request_id: 'mock-request-id',
    });
  }),
];

src/tests/mocks/data.ts
import type { User, PredictionResponse, Alert } from '@/types/api';

export const mockUsers: User[] = [
  {
    id: 1,
    email: 'test@example.com',
    name: 'Test User',
    role: 'user',
    is_active: true,
    created_at: '2024-01-01T00:00:00Z',
  },
];

export const mockPredictions: PredictionResponse[] = [
  {
    prediction: 1,
    flood_risk: 'high',
    risk_level: 2,
    risk_label: 'Critical',
    risk_color: '#d32f2f',
    risk_description: 'Severe flood risk. Take immediate precautions.',
    probability: 0.85,
    confidence: 0.92,
    model_version: 'v2.0',
    cache_hit: false,
    request_id: 'mock-request-id',
  },
];

export const mockAlerts: Alert[] = [
  {
    id: 1,
    risk_level: 2,
    risk_label: 'Critical',
    location: 'Parañaque City, NCR',
    message: 'Severe flooding detected in barangay San Antonio',
    delivery_status: 'delivered',
    created_at: '2024-01-15T10:30:00Z',
  },
  {
    id: 2,
    risk_level: 1,
    risk_label: 'Alert',
    location: 'Parañaque City, NCR',
    message: 'Moderate flood risk in coastal areas',
    delivery_status: 'pending',
    created_at: '2024-01-15T09:15:00Z',
  },
];

src/tests/unit/components/RiskDisplay.test.tsx
import { render, screen } from '@testing-library/react';
import { RiskDisplay } from '@/features/flooding/components/RiskDisplay';

describe('RiskDisplay', () => {
  test('renders safe risk level correctly', () => {
    render(<RiskDisplay riskLevel={0} />);
    
    expect(screen.getByText('Safe')).toBeInTheDocument();
    expect(screen.getByText('No significant flood risk. Normal conditions.')).toBeInTheDocument();
  });

  test('renders alert risk level correctly', () => {
    render(<RiskDisplay riskLevel={1} />);
    
    expect(screen.getByText('Alert')).toBeInTheDocument();
    expect(screen.getByText('Moderate flood risk. Stay informed and prepared.')).toBeInTheDocument();
  });

  test('renders critical risk level correctly', () => {
    render(<RiskDisplay riskLevel={2} />);
    
    expect(screen.getByText('Critical')).toBeInTheDocument();
    expect(screen.getByText('Severe flood risk. Take immediate precautions.')).toBeInTheDocument();
  });

  test('displays probability when provided', () => {
    render(<RiskDisplay riskLevel={1} probability={0.75} />);
    
    expect(screen.getByText('75.0% probability')).toBeInTheDocument();
  });
});

src/tests/unit/hooks/usePrediction.test.ts
import { renderHook, waitFor } from '@testing-library/react';
import { usePrediction } from '@/features/flooding/hooks/usePrediction';
import { server } from '../../mocks/server';
import { rest } from 'msw';

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());

describe('usePrediction', () => {
  test('should return prediction data', async () => {
    const { result } = renderHook(() => usePrediction());
    
    result.current.mutate({
      temperature: 303.15,
      humidity: 85,
      precipitation: 50,
    });
    
    await waitFor(() => expect(result.current.isSuccess).toBe(true));
    
    expect(result.current.data).toBeDefined();
    expect(result.current.data?.risk_level).toBe(2);
  });
});

15. Development Workflow


Git Branching Strategy

main (production-ready)
├── develop (integration branch)
└── feature/* (feature branches)
    ├── feature/prediction-form
    ├── feature/alert-system
    └── feature/user-auth

Commit Message Guidelines
feat: Add new feature
fix: Fix bug
docs: Documentation only changes
style: Formatting, missing semi colons, etc
refactor: Code change that neither fixes a bug nor adds a feature
test: Adding missing tests
chore: Other changes that don't modify src or test files

Development Commands

# Start development server
npm run dev

# Build for production
npm run build

# Run tests
npm run test

# Run tests with coverage
npm run test:coverage

# Run linter
npm run lint

# Run linter with auto-fix
npm run lint:fix

# Format code
npm run format

# Run type check
npm run typecheck

# Run all checks before commit
npm run lint && npm run typecheck && npm run test

Environment Setup
# Development environment
cp .env.example .env.development

# Set development API URL
VITE_API_BASE_URL=http://localhost:5000

# Production environment (after backend deployment)
cp .env.example .env.production

# Set production API URL
VITE_API_BASE_URL=https://your-backend.railway.app

Debugging Tips

Enable React DevTools for component inspection
Use React Query DevTools for API state debugging
Check browser network tab for API requests
Use console logs for debugging (remove before commit)
Enable Redux DevTools if using Redux

16. Deployment

### 16.1 Frontend Deployment (Vercel)

1. Connect GitHub repository to Vercel
2. Set build command: `npm run build`
3. Set output directory: `dist`
4. Add environment variables:
   - `VITE_API_BASE_URL`: Backend API URL
   - `VITE_SSE_URL`: Backend SSE URL

### 16.2 Backend Deployment Options

#### Option 1: Railway (Recommended)

```yaml
# railway.yml
services:
  - name: floodingnaque-backend
    buildCommand: pip install -r requirements.txt
    startCommand: gunicorn -w 4 -b 0.0.0.0:$PORT main:app
    env:
      - APP_ENV=production
      - DATABASE_URL=$DATABASE_URL
      - SECRET_KEY=$SECRET_KEY
      - JWT_SECRET_KEY=$JWT_SECRET_KEY
      - REDIS_URL=$REDIS_URL
```

#### Option 2: Render

```yaml
# render.yaml
services:
  - type: web
    name: floodingnaque-backend
    runtime: python
    buildCommand: pip install -r requirements.txt
    startCommand: gunicorn -w 4 -b 0.0.0.0:$PORT main:app
    envVars:
      - key: DATABASE_URL
        fromDatabase: floodingnaque-db
      - key: SECRET_KEY
        sync: false
```

#### Option 3: Docker Deployment

```dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

EXPOSE 5000

CMD ["gunicorn", "-w", "4", "-b", "0.0.0.0:5000", "main:app"]
```

### 16.3 Progressive Web App (PWA) Configuration

#### Web App Manifest

Create `public/manifest.json`:

```json
{
  "short_name": "Floodingnaque",
  "name": "Floodingnaque Flood Prediction System",
  "description": "Real-time flood risk predictions for Parañaque City",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#2563eb",
  "background_color": "#ffffff"
}
```

#### Service Worker for Offline Functionality

Create `src/service-worker.ts`:

```typescript
/// <reference lib="webworker" />
declare const self: ServiceWorkerGlobalScope;

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open('floodingnaque-v1').then((cache) => {
      return cache.addAll([
        '/',
        '/index.html',
        '/manifest.json',
        '/favicon.ico',
        '/logo192.png',
        '/logo512.png',
      ]);
    })
  );
});

self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request).then((response) => {
      return response || fetch(event.request);
    })
  );
});
```

#### Vite PWA Plugin

Install and configure the PWA plugin:

```bash
npm install -D vite-plugin-pwa
```

Update `vite.config.ts`:

```typescript
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import { VitePWA } from 'vite-plugin-pwa';
import path from 'path';

export default defineConfig({
  plugins: [
    react(),
    VitePWA({
      registerType: 'autoUpdate',
      workbox: {
        globPatterns: ['**/*.{js,css,html,ico,png,svg,woff2}'],
      },
      manifest: {
        short_name: 'Floodingnaque',
        name: 'Floodingnaque Flood Prediction System',
        description: 'Real-time flood risk predictions for Parañaque City',
        start_url: '.',
        display: 'standalone',
        theme_color: '#2563eb',
        background_color: '#ffffff',
      },
    }),
  ],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  server: {
    port: 3000,
    proxy: {
      // ... existing proxy configuration
    },
  },
});
```

#### PWA Installation Prompt

Create a PWA installation prompt component:

```tsx
// src/components/feedback/PWAInstallPrompt.tsx
import { useState, useEffect } from 'react';
import { useToast } from '@/hooks/useToast';

declare global {
  interface Window {
    deferredPrompt: Event;
  }
}

export function PWAInstallPrompt() {
  const [deferredPrompt, setDeferredPrompt] = useState<Event | null>(null);
  const { toast } = useToast();

  useEffect(() => {
    const handler = (e: Event) => {
      e.preventDefault();
      setDeferredPrompt(e);
      toast({
        title: 'Install App',
        description: 'Add Floodingnaque to your home screen for quick access',
        action: {
          label: 'Install',
          onClick: () => {
            if (deferredPrompt) {
              (deferredPrompt as any).prompt();
              (deferredPrompt as any).userChoice.then((choiceResult: { outcome: string }) => {
                if (choiceResult.outcome === 'accepted') {
                  console.log('User accepted the install prompt');
                }
                setDeferredPrompt(null);
              });
            }
          },
        },
      });
    };

    window.addEventListener('beforeinstallprompt', handler);

    return () => {
      window.removeEventListener('beforeinstallprompt', handler);
    };
  }, [deferredPrompt]);

  return null;
}
```

#### Offline Support

The service worker provides basic offline caching, but for critical functionality like receiving alerts:

- **SSE connections** will automatically reconnect when online
- **Cached data** remains accessible during offline periods
- **Background sync** can queue actions for when connectivity returns

> **Note**: Push notifications are planned for Phase 2. In the MVP, real-time alerts are handled via Server-Sent Events (SSE) which work over HTTP and don't require push notification infrastructure.


Frontend Deployment (Vercel)
Connect GitHub repository to Vercel
Set build command: npm run build
Set output directory: dist
Add environment variables:
VITE_API_BASE_URL: Backend API URL
VITE_SSE_URL: Backend SSE URL

Backend Deployment Options
Option 1: Railway (Recommended)
# railway.yml
services:
  - name: floodingnaque-backend
    buildCommand: pip install -r requirements.txt
    startCommand: gunicorn -w 4 -b 0.0.0.0:$PORT main:app
    env:
      - APP_ENV=production
      - DATABASE_URL=$DATABASE_URL
      - SECRET_KEY=$SECRET_KEY
      - JWT_SECRET_KEY=$JWT_SECRET_KEY
      - REDIS_URL=$REDIS_URL# railway.yml
services:
  - name: floodingnaque-backend
    buildCommand: pip install -r requirements.txt
    startCommand: gunicorn -w 4 -b 0.0.0.0:$PORT main:app
    env:
      - APP_ENV=production
      - DATABASE_URL=$DATABASE_URL
      - SECRET_KEY=$SECRET_KEY
      - JWT_SECRET_KEY=$JWT_SECRET_KEY
      - REDIS_URL=$REDIS_URL
Option 2: Render
# render.yaml
services:
  - type: web
    name: floodingnaque-backend
    runtime: python
    buildCommand: pip install -r requirements.txt
    startCommand: gunicorn -w 4 -b 0.0.0.0:$PORT main:app
    envVars:
      - key: DATABASE_URL
        fromDatabase: floodingnaque-db
      - key: SECRET_KEY
        sync: false
Option 3: Docker Deployment
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

EXPOSE 5000

CMD ["gunicorn", "-w", "4", "-b", "0.0.0.0:5000", "main:app"]

Environment Variables for Production
# Frontend (.env.production)
VITE_API_BASE_URL=https://your-backend.railway.app
VITE_SSE_URL=https://your-backend.railway.app/sse
VITE_APP_NAME=Floodingnaque
VITE_MAP_DEFAULT_LAT=14.4793
VITE_MAP_DEFAULT_LNG=121.0198
VITE_MAP_DEFAULT_ZOOM=13
VITE_ENABLE_SSE=true
VITE_SENTRY_DSN=https://your-sentry-dsn

# Backend (.env.production)
APP_ENV=production
SECRET_KEY=your-production-secret-key
JWT_SECRET_KEY=your-jwt-secret-key
DATABASE_URL=your-postgresql-url
REDIS_URL=your-redis-url
OWM_API_KEY=your-openweathermap-api-key
CORS_ORIGINS=https://floodingnaque.vercel.app

Deployment Checklist

 Backend deployed and accessible
 CORS configured for frontend domain
 Environment variables set
 SSL certificates configured
 Health checks working
 Error monitoring configured
 Performance monitoring enabled
 Backup strategy in place

17. MVP Roadmap

### 17.1 Phase Timeline

#### Phase 1: Foundation & Core Features (Week 1-4)
- [ ] Project scaffolding and pnpm workspace setup
- [ ] Authentication system (login/register)
- [ ] Basic prediction form and risk display
- [ ] Real-time alerts via **SSE** (Server-Sent Events)
- [ ] Basic dashboard layout
- [ ] Light/dark theme implementation
- [ ] Responsive design foundation
- [ ] API integration (prediction, data endpoints)

#### Phase 2: Enhanced Features (Week 5-8)
- [ ] **Web Push notifications** for background alerts
- [ ] Map visualization (Leaflet)
- [ ] Chart components (Recharts)
- [ ] Advanced prediction form with historical data
- [ ] User preferences and settings
- [ ] Advanced alert management
- [ ] PWA installation and offline support

#### Phase 3: Polish & Deploy (Week 9-10)
- [ ] Comprehensive testing (unit, integration, E2E)
- [ ] Performance optimization
- [ ] Error boundaries and loading states
- [ ] Production deployment
- [ ] Documentation and user guides

### 17.2 Success Metrics

| Metric | Target | Measurement |
|--------|--------|-------------|
| Page Load Time | < 2s | Web Vitals |
| API Response Time | < 500ms | Performance monitoring |
| User Engagement | 80% retention | Analytics |
| Error Rate | < 1% | Sentry monitoring |
| Mobile Responsiveness | 100% | Device testing |

> **Phase 1 Focus**: Real-time alerts via SSE (immediate implementation)  
> **Phase 2 Focus**: Web Push notifications (enhanced experience)

Success Metrics
Metric	Target	Measurement
Page Load Time	< 2s	Web Vitals
API Response Time	< 500ms	Performance monitoring
User Engagement	80% retention	Analytics
Error Rate	< 1%	Sentry monitoring
Mobile Responsiveness	100%	Device testing

Technical Debt Considerations
 Implement proper error boundaries
 Add comprehensive unit tests
 Set up CI/CD pipeline
 Implement proper logging
 Add security headers
 Optimize bundle size
 Implement caching strategies

Future Enhancements
 Machine learning model integration
 Advanced analytics dashboard
 Multi-language support
 Mobile app (React Native) (Not yet)
 Advanced alerting system
 Automated report generation
 Performance optimization